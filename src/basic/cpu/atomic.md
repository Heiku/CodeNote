
![](/img/cpu-lock.webp)

### 原子性原理

LOCK#：处理器提供一个 LOCK#，当一个处理器在总线上输出此信号时，其它处理器的请求将被阻塞，那么该处理器就能独自共享内存。

缓存一致性：缓存一致性会阻止同时修改由两个以上处理器的内存区域数据，当其他处理器回写被锁定的缓存行数据时，会使其他处理器的缓存行失效。
联想 `CPU Cache Line` [CPUCache](/src/Basic/cpu/CPUCache.java)

那么，既然有了缓存一致性，为什么还需要 volatile 呢？  
volatile 保证了当数据改动的时候，在写入操作后加入 store屏障（LOCK# 指令），使得数据能够立即写入到缓存，而缓存有了缓存一致性
所以才能使得其他缓存行中的数据失效从而需要从主存中获取。


### 指令重排序

1. 编译器优化重排序：编译器在不改变单线程语义的前提下，可以重新安排语句的执行顺序
2. 指令级并行重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序
3. 内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行


### happens-before

1. 程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作
2. 监视器锁规则：对每个锁的解锁操作，happens-before 于随后对这个锁的加锁操作
3. volatile域规则：对于一个 volatile 域的写操作，happens-before 于任意线程对这个 volatile 的读
4. 传递性规则：如果 A happens-before B，且 B happens-before C, 那么 A happens-before C