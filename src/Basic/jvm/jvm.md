### 字节码

字节码（Byte-Code）是一种包含执行程序，由一序列 op 代码/数据对组成的二进制文件。通常每个操作码是一字节长，所以字节码的程度
是根据一字节来的。

实现方式：通过编译器和虚拟机，编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译成可直接执行的指令，在 Java 中，
通过 `javac` 将源文件（.java）变成字节码 (.class）。


### 内存分配

Java 中所有对象实例和数据都是在 Java 堆上分配，为对象分配内存就是把一块大小确定的内存从堆内存中划分出来。

1. 指针碰撞法
假设 Java 堆中的内存是完整的，已分配的内存和空闲内存分别位于堆内存的两边，通过一个指针，当需要分配内存时，
仅仅需要把指针往空闲的一端移动与对象大小相等的距离。

2. 空闲列表法
事实上，Java 堆的内存并不是整齐分布的，已分配的内存和未分配的内存空间相互交错，JVM 通过维护一个空闲列表，记录了
可用的内存块信息，当分配块发生时，从列表中找到y一个足够大的内存块分配给对象实例，并更新列表上的记录。

对象的创建是一个非常频繁的行为，进行堆内存分配时还需要考虑多线程并发问题，可能出现正在给对象A 分配内存，
指针或记录还未更新，对象B 又同时分配到原来的内存。解决办法：
1. 采用 CAS 保证数据更新操作的原子性
2. 把内存分配的行为按照线程进行划分，在不同的空间进行，每个线程在 Java堆中预先分配一个内存块，
称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）

#### 逃逸分析

并非所有的对象都在堆上分配内存。

* 逃逸分析

__逃逸__ 是指在某个方法内创建的对象除了方法体之内被引用之外，还在方法体之外被其他变量引用到。这样带来的 __影响__ 是，
在方法执行完毕之后，该方法创建的对象将无法被 GC 回收。由于被其他变量引用导致的无法回收，这个过程称为 __逃逸__。

__逃逸分析技术__ 可以分析出对象是否永远在某个方法、线程范围内，并没有 "逃逸" 出这个范围，逃逸分析的一个结果就是
对某些未逃逸对象k恶意直接在栈上分配提高对象分配的回收效率，对象占用的空间也会随着 __栈帧__ 的出栈而销毁。

## JVM

JVM 运行结构：方法区 + 虚拟机栈 + 本地方法栈 + 程序计数器 + 虚拟机堆

### Java堆

Java堆是被所有线程共享的一块内存区域，此内存的唯一目的就是存放实例，几乎所有对象的实例都在这里分配内存。  
Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。

### Java栈

Java栈是线程私有的，每个线程对应一个 Java栈，每个线程在执行一个方法时会创建一个对应的栈帧（Stack Frame），
栈帧负责存储局部变量表、操作数栈、动态链接和方法返回地址等信息。每个方法的调用过程，相当于栈帧在 Java栈的入栈和出栈的过程。
[base](/src/Basic/asm/base.md) 

### 栈帧

栈帧：局部变量表 + 操作数栈 + 动态链接 + 方法的返回地址  

方法调用在 JVM 中转换成字节码执行，字节码执行的数据结构就是栈帧 （stack frame），也就是在虚拟机栈 （JVM Stacks）中的栈元素。
虚拟机会为每个方法分配一个栈帧，根据栈的特性（LIFO 先进后出），栈顶的元素就是当前线程正在活动的栈帧（Current Stack），
字节码的执行操作(invoke)，也就对应着对当前栈帧数据结构的操作。


#### 局部变量表

局部变量表是一组变量值存储空间，用于存放 __方法参数__ 和方法内部定义的 __局部变量__。随着进入方法开辟，退出方法回收。

局部变量表的容量是以 slot 为最小单位，32位的虚拟机中一个 slot 可以存放 32位以内的数据类型（boolean, byte, char, short, int,
float, reference, returnAddress）。其中除了 long/double 分配8字节空间，其他都是4字节空间。

[LocalVariableTableDemo](/src/Basic/asm/LocalVariableTableDemo.java)


#### 操作数栈

操作数栈：JVM 解释执行引擎（基于栈的执行引擎）

操作数栈和局部变量表一样，在编译期间决定了存储空间，通过 Code 属性存储在类或接口的字节流中，（LIFO 栈）

#### 动态链接

动态链接就是将符号引用的方法，转换成方法的直接引用。

符号引用就是字符串，这个字符串包含足够的信息，以供实际使用时可以找到相应的位置。你比如说某个方法的符号引用，
如：“java/io/PrintStream.println:(Ljava/lang/String;)V”。里面有类的信息，方法名，方法参数等信息。  
  
当第一次运行时，要根据字符串的内容，到该类的方法表中搜索这个方法。运行一次之后，符号引用会被替换为直接引用，下次就不用搜索了。
直接引用就是偏移量，通过偏移量虚拟机可以直接在该类的内存区域中找到方法字节码的起始位置。

### 方法区

方法区和 Java堆一样，是所有线程共享的内存区域，用于存放已被虚拟机加载的类信息、常量、静态变量和即时编译器编译后的代码等数据。  
运行时常量池是方法区的一部分，用于存放编译期间生成的各种字面常量和符号引用。

方法区分成 PermGem 和 CodeCache: PermGem 存放 Java 类的相关信息，如静态遍历、成员方法和抽象方法等；CodeCache 存放 JIT 编译后的
本地代码。


#### 程序计数器

程序计数器是线程私有的，每个线程都有独立的指令计数器，计数器记录着虚拟机正在执行的字节码的地址，
分支异常处理和线程恢复等操作都依赖这个计数器完成，如果线程执行的 `native` 方法，那么这个计数器为空。
分支、跳转、循环、异常处理、线程恢复等功能。

### 对象的内存分布

对象在内存分布可以分为三块区域：对象头、实例数据和对齐补充

#### 对象头

对象头包括两部分信息：运行时数据和类型指针，如果对象是一个数组，还需要一块用于记录数组长度的数据。

* 运行时数据
运行时数据包括了 HashCode、GC 分代年龄、锁状态标志、线程持有的锁、偏向锁ID和偏向时间戳等。这部分数据在32位和64位虚拟机中
的长度分别为32bit 和 64bit，官方称为 `Mark Word`. Mark Word 被设计成非固定的数据结构，以实现在有限空间内保存尽可能多的
数据。  
在32位的虚拟机中，对象未被锁定的情况下，Mark Word 的32bit中 = HashCode(25bit) + GC age(4bit) + lock record(2bit) + 0(1bit)

Mark Word 存储内容如下：
轻量级锁定（00）:指向锁记录的指针  
重量级锁定（10）:指向重量级锁的指针  
GC 标志（11）: 空  
可偏向（01）:偏向线程ID、时间戳、分代年龄  
未锁定（01）:对象哈希码、分代年龄  


* 类型指针
类型指针指向该对象的类元数据，虚拟机通过这个指针可以确定该对象是哪个类的实例

![](/img/mark-word.webp)

#### 实例数据

实例数据就是在程序代码中所定义的各种类型的代码，包括从父类继承的，这部分的存储顺序会受到虚拟机分配策略和字段在源码中
定义顺序的影响。

#### 对象填充

由于HotSpot 的自动内存管理要求对象的起始地址必须是8字节的整数倍，即对象大小必须是8字节的整数倍，对象头的数据正好是8的整数倍，
所以当实例数据不够8字节的整数倍时，需要通过对齐填充进行补全。


### JVM 类加载

Java 源代码被编译成 class 字节码，最终需要加载到虚拟机中才能运行。整个生命周期包括了：加载、验证、准备、解析、初始化、
使用、卸载着7个阶段。

#### 加载

获取类的资源字节流并转换成方法区运行的数据结构，同时在堆中生成对应的 Class 对象

1. 通过一个类的全限定名(java.lang.String)获取描述此类的二进制字节流
2. 通过这个字节流所代表的静态存储结构保存为方法区的运行时数据结构
3. 在 Java 堆中生成一个代表这个类的 java.lang.Class 对象，作为访问方法区的入口

类加载器：
1. 启动类加载器(Bootstrap ClassLoader): 负责加载 JAVA_HOME\lib 下的类库，如 rt.jar
2. 扩展类加载器(Extension ClassLoader): 负责加载 JAVA_HOME\lib\ext 下的类库
3. 应用程序类加载器(Application ClassLoader): 负责加载用户路径 (classpath) 上的类库

双亲委派模型：  
当一个类加载器受到类的加载任务，会优先给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类
加载器无法完成加载任务时，才会尝试执行任务。（例如位于 rt.jar 中的 java.lang.Object，无论哪个类加载器加载这个类，最终
都是委托给顶层的启动类加载器进行执行，确保了 Object 类在各种加载器环境中都是同一个类）

#### 验证

验证字节流（Class 文件）是否符合当前虚拟机的要求，防止篡改过的字节码危害 JVM 安全

1. 格式验证
验证字节流是否符合 class 文件格式的规范，并且能被当前虚拟机处理，如是否以魔数0xCAFEBABE开头、主次版号是否在当前的虚拟机
处理范围内、常量池是否有不支持的常量类型。只有经过格式验证的字节流，才会存储到方法区的数据结构，剩余的3个验证都是基于
方法区的数据进行。

2. 元数据验证
对字节码描述的数据进行语义分析，以保证符合Java 语言规范，如是否继承了final 修饰的类、是否实现了父类的抽象方法、是否覆盖
了父类的final 方法或final 字段。

3. 字节码验证
对类的方法体进行分析，确保在方法运行时不会有危害虚拟机的事件发生，如保证操作数栈的数据类型和指令代码序列的匹配，
保证跳转指令的正确性、保证类型转换的有效性等

4. 符号引用验证
为了确保后续的解析动作能够正常执行，对符号引用进行验证，如字符串描述的全限定名是否能找到对应的类，在指定类中是否存在
符合方法的字符描述等。

#### 准备

为类变量(static) 在方法区中分配内存并设置初始值。（区别于初始化阶段的实际值分配）

#### 解析

解析阶段是将常量池中的符号引用替换为直接引用的过程。

* 符号引用：使用一组符号来描述所引用的目标，可以是任何形式的字面常量，定义在 Class 文件格式中
* 直接引用：直接指向目标的指针、相对偏移量或能间接定位到目标的句柄

#### 初始化

执行静态变量赋值、静态块、类构造方法

初始化触发操作：
* 执行 new、getstatic、putstatic 和 invokestatic指令
* 使用 reflect 对类进行反射调用
* 初始化一个类时，父类还没有初始化，会事先初始化父类
* 在启动虚拟机时，需要初始化包含 main() 的类


### 方法调用

Java 文件在编译期间不会进行传统编译的连接步骤，方法调用的目标方法以符号引用的方式存储在 Class 文件中，虽然带来了
更灵活的扩展能力，但也使得方法调用变得相对复杂，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。

所有方法调用的目标方法在 Class 文件里面都是常量池中的符号引用。直到在类加载的解析阶段，如果一个方法在运行前之前有
确定的调用版本，且在运行期间不变，虚拟机会将其符号引用解析成直接引用。

JVM 中提供了如下的方法调用字节码指令：

1. invokestatic: 调用静态方法
2. invokespecial: 调用实例构造方法<init>，私有方法和父类方法
3. invokevirtual: 调用虚方法
4. invokeinterface: 调用接口方法，在运行时再确定一个实现此接口的对象
5. invokedynamic: 再运行期间动态解析出调用点限定符引用的方法之后，调用该方法

通过 invokestatic 和 invokespecial （非虚方法）指令调用的方法，可以再解析阶段确定唯一的调用版本，符合这种条件的有
静态方法、私有方法、实例构造器和父类方法4种，它们在类加载时会把符号引用解析为该方法的直接引用。

#### 动态分派

由于动态分派是非常频繁的操作，因此在虚拟机的实际实现中，会基于性能的考虑，并不会如此频繁的搜索对应的方法，
一般会在方法区中建立一个虚方法表，使用虚方法表代替方法查询以提高性能。

虚方法表在类加载的连接阶段初始化，存放着各个方法的实际入口地址，如果某个方法在子类中没有重写，那么子类的虚方法表中
该方法的入口地址和父类保持一致。


### new

1. 先检查是否能在运行方法区中的常量池找对对应类的符号引用，否则进行类加载
2. 划分内存空间，指针碰撞和空间列表（多线程划分（CAS、TLAB））
3. 设置对象信息（对象头-元数据、hashcode、gc age、所偏向id等） 


### 引用
[JVM内存的那些事](https://www.jianshu.com/p/eaef248b5a2c)  
[教你用Java字节码做点有趣的事](https://juejin.im/post/5b51ff276fb9a04f914a922e)  
[JVM里的符号引用如何存储？](https://www.zhihu.com/question/30300585)  
[JVM类加载的那些事](https://www.jianshu.com/p/2133558b4735)  
[JVM方法调用的那些事](https://www.jianshu.com/p/56a7c4b26b14)  