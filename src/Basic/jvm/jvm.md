
### 内存分配

Java 中所有对象实例和数据都是在 Java 堆上分配，为对象分配内存就是把一块大小确定的内存从堆内存中划分出来。

1. 指针碰撞法
假设 Java 堆中的内存是完整的，已分配的内存和空闲内存分别位于堆内存的两边，通过一个指针，当需要分配内存时，
仅仅需要把指针往空闲的一端移动与对象大小相等的距离。

2. 空闲列表法
事实上，Java 堆的内存并不是整齐分布的，已分配的内存和未分配的内存空间相互交错，JVM 通过维护一个空闲列表，记录了
可用的内存块信息，当分配块发生时，从列表中找到y一个足够大的内存块分配给对象实例，并更新列表上的记录。

对象的创建是一个非常频繁的行为，进行堆内存分配时还需要考虑多线程并发问题，可能出现正在给对象A 分配内存，
指针或记录还未更新，对象B 又同时分配到原来的内存。解决办法：
1. 采用 CAS 保证数据更新操作的原子性
2. 把内存分配的行为按照线程进行划分，在不同的空间进行，每个线程在 Java堆中预先分配一个内存块，
称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）


### Java栈

Java栈是线程私有的，每个线程对应一个 Java栈，每个线程在执行一个方法时会创建一个对应的栈帧（Stack Frame），
栈帧负责存储局部变量表、操作数栈、动态链接和方法返回地址等信息。每个方法的调用过程，相当于栈帧在 Java栈的入栈和出栈的过程。
[base](/src/Basic/asm/base.md) 

### 方法区

方法区和 Java堆一样，是所有线程共享的内存区域，用于存放已被虚拟机加载的类信息、常量、静态变量和即时编译器编译后的代码等数据。  
运行时常量池是方法区的一部分，用于存放编译期间生成的各种字面常量和符号引用。

#### 指令计数器

指令计数器是线程私有的，每个线程都有独立的指令计数器，计数器记录着虚拟机正在执行的字节码的地址，
分支、循环、跳转、异常处理和线程恢复等操作都依赖这个计数器完成，如果线程执行的 `native` 方法，那么这个计数器为空。

### 对象的内存分布

对象在内存分布可以分为三块区域：对象头、实例数据和对齐补充

#### 对象头

对象头包括两部分信息：运行时数据和类型指针，如果对象是一个数组，还需要一块用于记录数组长度的数据。

* 运行时数据
运行时数据包括了 HashCode、GC 分代年龄、锁状态标志、线程持有的锁、偏向锁ID和偏向时间戳等。这部分数据在32位和64位虚拟机中
的长度分别为32bit 和 64bit，官方称为 `Mark Word`. Mark Word 被设计成非固定的数据结构，以实现在有限空间内保存尽可能多的
数据。  
在32位的虚拟机中，对象未被锁定的情况下，Mark Word 的32bit中 = HashCode(25bit) + GC age(4bit) + lock record(2bit) + 0(1bit)

Mark Word 存储内容如下：
轻量级锁定（00）:指向锁记录的指针  
重量级锁定（10）:指向重量级锁的指针  
GC 标志（11）: 空  
可偏向（01）:偏向线程ID、时间戳、分代年龄  
未锁定（01）:对象哈希码、分代年龄  


* 类型指针
类型指针指向该对象的类元数据，虚拟机通过这个指针可以确定该对象是哪个类的实例

![](/img/mark-word.webp)

#### 实例数据

实例数据就是在程序代码中所定义的各种类型的代码，包括从父类继承的，这部分的存储顺序会受到虚拟机分配策略和字段在源码中
定义顺序的影响。

#### 对象填充

由于HotSpot 的自动内存管理要求对象的起始地址必须是8字节的整数倍，即对象大小必须是8字节的整数倍，对象头的数据正好是8的整数倍，
所以当实例数据不够8字节的整数倍时，需要通过对齐填充进行补全。


### 引用
[JVM内存的那些事](https://www.jianshu.com/p/eaef248b5a2c)