### 字节码

字节码（Byte-Code）是一种包含执行程序，由一序列 op 代码/数据对组成的二进制文件。通常每个操作码是一字节长，所以字节码的程度
是根据一字节来的。

实现方式：通过编译器和虚拟机，编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译成可直接执行的指令，在 Java 中，
通过 `javac` 将源文件（.java）变成字节码 (.class）。


### 内存分配

Java 中所有对象实例和数据都是在 Java 堆上分配，为对象分配内存就是把一块大小确定的内存从堆内存中划分出来。

1. 指针碰撞法
假设 Java 堆中的内存是完整的，已分配的内存和空闲内存分别位于堆内存的两边，通过一个指针，当需要分配内存时，
仅仅需要把指针往空闲的一端移动与对象大小相等的距离。

2. 空闲列表法
事实上，Java 堆的内存并不是整齐分布的，已分配的内存和未分配的内存空间相互交错，JVM 通过维护一个空闲列表，记录了
可用的内存块信息，当分配块发生时，从列表中找到y一个足够大的内存块分配给对象实例，并更新列表上的记录。

对象的创建是一个非常频繁的行为，进行堆内存分配时还需要考虑多线程并发问题，可能出现正在给对象A 分配内存，
指针或记录还未更新，对象B 又同时分配到原来的内存。解决办法：
1. 采用 CAS 保证数据更新操作的原子性
2. 把内存分配的行为按照线程进行划分，在不同的空间进行，每个线程在 Java堆中预先分配一个内存块，
称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）


### Java栈

Java栈是线程私有的，每个线程对应一个 Java栈，每个线程在执行一个方法时会创建一个对应的栈帧（Stack Frame），
栈帧负责存储局部变量表、操作数栈、动态链接和方法返回地址等信息。每个方法的调用过程，相当于栈帧在 Java栈的入栈和出栈的过程。
[base](/src/Basic/asm/base.md) 

### 栈帧

栈帧：局部变量表 + 操作数栈 + 动态链接 + 方法的返回地址  

方法调用在 JVM 中转换成字节码执行，字节码执行的数据结构就是栈帧 （stack frame），也就是在虚拟机栈 （JVM Stacks）中的栈元素。
虚拟机会为每个方法分配一个栈帧，根据栈的特性（LIFO 先进后出），栈顶的元素就是当前线程正在活动的栈帧（Current Stack），
字节码的执行操作(invoke)，也就对应着对当前栈帧数据结构的操作。


#### 局部变量表

局部变量表是一组变量值存储空间，用于存放 __方法参数__ 和方法内部定义的 __局部变量__。随着进入方法开辟，退出方法回收。

局部变量表的容量是以 slot 为最小单位，32位的虚拟机中一个 slot 可以存放 32位以内的数据类型（boolean, byte, char, short, int,
float, reference, returnAddress）。其中除了 long/double 分配8字节空间，其他都是4字节空间。

[LocalVariableTableDemo](/src/Basic/asm/LocalVariableTableDemo.java)


#### 操作数栈

操作数栈：JVM 解释执行引擎（基于栈的执行引擎）

操作数栈和局部变量表一样，在编译期间决定了存储空间，通过 Code 属性存储在类或接口的字节流中，（LIFO 栈）

#### 动态链接

动态链接就是将符号引用的方法，转换成方法的直接引用。

符号引用就是字符串，这个字符串包含足够的信息，以供实际使用时可以找到相应的位置。你比如说某个方法的符号引用，
如：“java/io/PrintStream.println:(Ljava/lang/String;)V”。里面有类的信息，方法名，方法参数等信息。  
  
当第一次运行时，要根据字符串的内容，到该类的方法表中搜索这个方法。运行一次之后，符号引用会被替换为直接引用，下次就不用搜索了。
直接引用就是偏移量，通过偏移量虚拟机可以直接在该类的内存区域中找到方法字节码的起始位置。

### 方法区

方法区和 Java堆一样，是所有线程共享的内存区域，用于存放已被虚拟机加载的类信息、常量、静态变量和即时编译器编译后的代码等数据。  
运行时常量池是方法区的一部分，用于存放编译期间生成的各种字面常量和符号引用。

#### 指令计数器

指令计数器是线程私有的，每个线程都有独立的指令计数器，计数器记录着虚拟机正在执行的字节码的地址，
分支、循环、跳转、异常处理和线程恢复等操作都依赖这个计数器完成，如果线程执行的 `native` 方法，那么这个计数器为空。

### 对象的内存分布

对象在内存分布可以分为三块区域：对象头、实例数据和对齐补充

#### 对象头

对象头包括两部分信息：运行时数据和类型指针，如果对象是一个数组，还需要一块用于记录数组长度的数据。

* 运行时数据
运行时数据包括了 HashCode、GC 分代年龄、锁状态标志、线程持有的锁、偏向锁ID和偏向时间戳等。这部分数据在32位和64位虚拟机中
的长度分别为32bit 和 64bit，官方称为 `Mark Word`. Mark Word 被设计成非固定的数据结构，以实现在有限空间内保存尽可能多的
数据。  
在32位的虚拟机中，对象未被锁定的情况下，Mark Word 的32bit中 = HashCode(25bit) + GC age(4bit) + lock record(2bit) + 0(1bit)

Mark Word 存储内容如下：
轻量级锁定（00）:指向锁记录的指针  
重量级锁定（10）:指向重量级锁的指针  
GC 标志（11）: 空  
可偏向（01）:偏向线程ID、时间戳、分代年龄  
未锁定（01）:对象哈希码、分代年龄  


* 类型指针
类型指针指向该对象的类元数据，虚拟机通过这个指针可以确定该对象是哪个类的实例

![](/img/mark-word.webp)

#### 实例数据

实例数据就是在程序代码中所定义的各种类型的代码，包括从父类继承的，这部分的存储顺序会受到虚拟机分配策略和字段在源码中
定义顺序的影响。

#### 对象填充

由于HotSpot 的自动内存管理要求对象的起始地址必须是8字节的整数倍，即对象大小必须是8字节的整数倍，对象头的数据正好是8的整数倍，
所以当实例数据不够8字节的整数倍时，需要通过对齐填充进行补全。


### 引用
[JVM内存的那些事](https://www.jianshu.com/p/eaef248b5a2c)  
[教你用Java字节码做点有趣的事](https://juejin.im/post/5b51ff276fb9a04f914a922e)  
[JVM里的符号引用如何存储？](https://www.zhihu.com/question/30300585)