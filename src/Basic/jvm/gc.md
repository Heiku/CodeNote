
### GC

Java 堆是被所有线程共享的一块内存区域，所有对象实例和数组都在堆上进行分配。为了高效的垃圾回收，虚拟机把堆内存划分成新生代（Young Generation）、
老年代（Old Generation）和永久代（Permanent Generation）3个区域。

在 HotSpot VM 的实现中，主要有两大类GC：
1. Partial GC：并不会对整个 GC 堆进行收集

* young gc(Minor GC): 只收集 young gen 的GC
* old gc: 只收集 old gen 的 GC，只有 CMS 的 concurrent collection
* mixed gc: 收集整个 young gen 以及部分 old gen 的GC ，只有G1 中正在使用。

2. Full GC: 收集整个堆，包括young fen、old gen、perm gen（如果存在的话）等



![](/src/img/gc-menory.webp)

#### 新生代

新生代由 Eden 和 Survivor Space (S0, S1) 构成，大小通过 `-Xmn` 指定，Eden 与 Survivor Space 的内存大小比例默认为 8: 1，
可以通过 `-XX:SurvivorRatio` 参数指定，比如新生代为10M 时，Eden 分配8M，S0 和 S1 各分配1M。

* Eden: 大多数情况下，对象在 Eden 中分配，当 Eden 没有足够空间时，会触发一次 Minor GC，虚拟机提供了 `-XX:PrintGCDetail` 参数，
告诉虚拟机在发生垃圾回收时打印内存回收日志

* Survivor: 幸存者，是新生代和老年代的缓冲区域。当新生代发生 GC（Minor GC）时，会将存活的对象移动到 S0 内存区域，并清空 Eden 区域，
当再次发生 Minor GC 时，将 Eden 和 S0 中存活的对象移动到 S1 内存区域。

存活对象会反复在 S0 和 S1之间移动，当对象从 Eden 移动到 Survivor 或者在 Survivor 之间移动时，对象的GC年龄自动累加，当 GC年龄
超过阈值15时，会将该对象移动到老年代，可以通过参数 `-XX:MaxTenuringThreshold` 对 GC 年龄进行阈值设置


#### 老年代

老年代的空间大小即 `-Xmx` 与 `-Xmn` 两个参数之差，用于存放经过几次 Minor GC 之后已经存活的对象。当老年代的空间不足时，会触发
Major GC/ Full GC，速度比 Minor GC 慢10倍以上。

##### 直接进入老年代的情况

1. 大对象，`-XX:PretenureSizeThreshold` 大于这个参数的对象将直接在老年代分配，避免新生代 GC 以及分配担保机制和 Eden 与 Survivor
之间的复制
2. 经过第一次 Minor GC 仍然存在，能被 Survivor 容纳，就会被移动到 Survivor 中，此时年龄为1，当年龄大于预设值j就进入老年代
3. 如果 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于等于该年龄的对象进入老年代
4. 如果 Survivor 无法容纳经过 Minor GC 还存活的对象

#### 永久代

在 JDK8 之前的 Hotspot 实现中，类的元数据如方法数据、方法信息（字节码，栈和变量大小）、运行时常量池、已确定的符号引用和虚方法表等
都被保存在永久代中，32位默认永久代的大小位64M，64位默认为85M，可以通过 `-XX:MaxPermSize` 进行设置，一旦类的元数据超过永久代大小，
抛出OOM异常。

在 JDK8 的 HotSpot中，把永久代从堆中移除了，并把类的元数据直接保存在本地内存区域（对外内存），称为元空间。这样做在于永久代的调优非常
困难，大小很难确定，而且涉及到太多因素，如类的总数、常量池大小和方法数量等，同时永久代的数据会随着每次 Full GC 而发生移动。

JDK8 中，类的元数据保存在本地内存中，元空间的最大可分配空间就是系统可用空间，可以避免永久代的内存溢出问题，不过需要监控内存的消耗情况，
一旦发生内存泄漏，会占用大量的本地内存。

### 判断对象存活

GC 动作发生之前，需要先确定堆内存中哪些对象是存活的，一般有两种方法：引用计数法和可达性分析法

1. 引用计数法：在对象上添加一个引用计数器，每当有一个对象引用它时，计数器+1，当使用完该对象时，计数器-1，计数器为0的对象表示不能
在被使用。引用计数法实现简单，判定高效，但不能解决对象之间相互引用的问题。[GCTest](gc/GCTest.java)

2. 可达性分析法：以 "GC Roots" 作为起点，从这些点开始向下搜索，搜索路径称为 "引用链"。当一个对象到 GC Roots 没有任何引用链时，
意味着该对象可以被回收。

GC Roots：  
* 本地变量表中的引用对象
* 方法区中静态变量引用的对象
* 方法区中常量引用的对象
* Native 方法引用的对象

![](/img/gc-roots.webp)

在可达性分析法中，判定一个对象objA 是否可以被回收，至少要经历两次标记过程：
1. 如果对象objA 到 GC Roots 没有引用链，则进行第一次标记
2. 如果对象objA 重写了 `finalize()` 方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建、低优先级的
 Finalizer 线程触发其 finalize()。finalize() 是对象逃脱死亡的最后一次机会，GC 会对队列中的对象进行第二次标记，如果 objA 在 finalize()
  在引用链上的任何一个对象建立联系，那么在第二次标记时，objA 会被移出 “即可回收” 集合。[FinalizerTest](gc/FinalizerTest.java)
  

### 垃圾收集算法

垃圾回收算法：标记-清除，复制和 标记-整理

1. 标记-清除算法
对待回收的对象进行标记  
缺点：效率问题，标记和清除的过程效率很低；空间问题，收集后会产生大量的内存碎片，不利于大对象的分配。

2. 复制算法
复制算法将可用内存划分大小相等的两块 A 和 B，每次只使用其中一块，当 A 的内存用完了，就将存活的对象复制到B，并清空 A 的内存，不仅提高了
标记的效率，因为只需要标记存活的对象，同时也避免了内存碎片的问题，代价是可用内存缩小为原来的一般。

3. 标记-整理算法
在老年代中，对象的存活率比较高，复制算法的效率比较低。在标记-整理算法中，标记出所有存活的对象，并移动到一端，然后直接清理边界以外的内存.


### 对象标记过程
在可达性分析法中，为了准确找出与 GC Roots 相关联的对象，必须要求整个执行引擎看起来像是被冻结在某个时间点上（Stop the world），即暂停
所有运行中的线程，不可以出现对象的引用关系还在不断变换的情况。

#### 如何快速枚举 GC Roots

GC Roots 主要在全局性的引用（常量或类静态属性）与执行上下文（本地变量表中的引用）中，很多应用仅仅方法区就上百兆，如果进行遍历查找，
效率会非常低下。

在 HotSpot 中，使用一组称为 OopMap 的数据结构进行实现。类加载完成时，HotSpot 把对象内什么偏移量上是什么类型的数据计算出来存储到 OopMap中，
通过 JIT 编译出来的本地代码，也会记录下栈和寄存器中哪些位置是引用。GC 发生时，通过扫描 OopMap 的数据就可以快速标识出存活的对象。

#### 如何安全的 GC？

线程运行时，只有在到达安全点（Safe Point）才能停顿下来进行GC。

基于 OopMap 数据结构，HotSpot 可以快速地完成 GC Roots 的遍历，不过 HotSpot 并不会为每条指令都生成对应的 OopMap，只会在 Safe Point
处理这些信息。

Safe Point的选择很重要，如果太少可能导致 GC 等待时间过长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，
通常会选择一些执行较长的指令作为 Safe Point，如方法调用、循环跳转、异常跳转等。


#### 发生 GC 时，如何让所有线程跑到最近的 Safe Point 再暂停？

当发生 GC 时，不直接对线程进行中断操作，而是简单地设置一个中断标志，每个线程运行到 Safe Point 的时候，主动地去轮询这个中断标志，
如果中断标志为真，则将自己进行中断挂起。

这里忽略了一个问题，如果发生 GC 时，运行中的线程可以跑到 Safe Point后进行挂起，而那些对于 Sleep 或者 Blocked 状态的线程此时无法响应
JVM 的中断请求，无法到 Safe Point处进行挂起，针对这种情况，可以使用安全区域（Safe Region）进行解决。

Safe Region是指在一段代码片段中，对象的引用关系不会发生变化，这个区域中的任何位置开始 GC 都是安全的。
1. 当线程运行到 Safe Region 的代码时，首先标识已经进入到了 Safe Region，如果这段时间内发生 GC，JVM 会忽略标识标识为 Safe Region 的线程
2. 当线程即将离开 Safe Region时，会检查 JVM 是否已经完成 GC，如果完成了，则继续运行，否则线程必须等到直到收到可以安全离开 Safe Region
的信号为止。

### 垃圾收集器

![](/img/gc-collecter.webp)


在 GC收集器实现中，分为了单线程、并行和并发。

* 单线程收集器：如 Serial GC，即垃圾收集过程中只有单一线程在进行收集工作
* 并行收集器：如 Parallel GC，每次运行时，不管是 YGC，还是 FGC，都会 Stop-the-world，暂停所有的用户线程，并采用多个线程同时
进行垃圾回收
* 并发收集器：如 CMS GC，在新生代进行垃圾回收时和并行收集器类似，都是并行收集，而且都会 stop-the-world，主要的区别在于老年代的收集
上，CMS 在老年代进行垃圾收集时，大部分时间可以和用户线程并发执行的，只有小部分时间 stop-the-world，这就是它的优势，可以大大降低
应用的暂停时间，当然也存在劣势。

1. Serial 收集器（串行GC）
Serial 是一个采用单线程并基于复制算法工作的新生代的收集器，进行垃圾回收时，必须暂停其他所有的工作线程。对于单 CPU 环境来说，Serial
没有线程交互的开销，可以很高效的进行垃圾收集动作，是 Client 模式下新生代的默认收集器。

2. ParNew 收集器（并行GC）
ParNew 其实是 Serial 的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与 Serial 一样。

3. Parallel Scavenge 收集器（并行回收GC）
Parallel Scavenge 是一个采用多线程基于复制算法并工作在新生代的收集器，其关注点在于达到一个可控的吞吐量，经常被称为 “吞吐量优先”收集器。

吞吐量 = 用户代码运行时间 / （用户代码运行时间 + 垃圾回收时间）

Parallel Scavenge 提供了两个参数用于精确控制吞吐量：  
1. `-XX:MaxGCPauseMillis` 设置垃圾收集的最大停顿时间
2. `-XX:GCTimeRadio` 设置吞吐量大小

4. Serial Old 收集器（串行GC）
Serial Old 是一个采用单线程基于标记-整理并工作在老年代的收集器，是 Client 模式下老年代默认的收集器

5. Parallel Old 收集器（并行GC）
Parallel Old 是一个采用多线程基于标记整理并工作在老年代的收集器。在注重吞吐量以及 CPU 资源敏感的场合，可以优先考虑 Parallel Scavenge
和 Parallel Old 的收集器组合。

6. CMS 收集器（并发GC）
CMS（Concurrent Mark Sweep）是一种以获取最短回收停顿时间为目标的收集器，工作在老年代，基于 “标记-清除” 算法实现，整个过程分为4步：
`-XX:+UseCMSInitiatingOccupancyOnly` 使用参数控制 cms 老年代使用率的触发阈值

1. 初始标记：这个过程只是标记一下 GC Roots能够直接关联的对象，但是仍然会 Stop The World
2. 并发标记：进行 GC Roots Tracing 的过程，可以和用户线程一起工作。
3. 重新标记：用于修正并发标记期间由于用户程序继续运行而导致标记产生变动的那部分记录，这个过程会暂停所有线程，但其暂停时间远比并发标记的
时间短。
4. 并发清理：可以和用户线程一起工作


CMS 收集器的缺点：  
1. 对 CPU 资源比较敏感，在并发阶段，虽然不会导致用户线程停顿，但是会占用一部分线程资源，降低系统的总吞吐量。
2. 无法处理浮动垃圾，在并发清理阶段，用户线程的运行依然会产生新的垃圾对象，这部分垃圾只能在下一次GC时收集。
3. CMS 是基于标记-清除算法实现的，意味着收集结束后会产生大量的内存碎片，可能导致出现老年代剩余空间很大，却无法找到足够大的连续空间
分配当前对象，不得不提前触发一次 Full GC。

cms gc 与 full gc 的区别：  

* cms gc: 通过一个后台线程触发，触发机制是默认每隔2秒判断一下当前老年代的内存使用率是否达到阈值，当然具体的触发条件没有这么简单，
如果是则触发一次 CMS GC，在该过程中只会标记出存活的对象，然后清除死亡对象，期间会产生碎片空间。

* full gc: 通过vm thread 执行的，整个过程是 stop-the-world，在该过程中会判断当前 gc 是否需要 compact，即把存活对象移动到
内存的一端，可以有效的消除 cms gc 产生的碎片空间。


7. G1 收集器
G1（Garbage First）是 JDK1.7 提供的一个在工作在新生代和老年代的收集器，基于 ”标记-整理“ 算法，在收集结束后可以避免内存碎片问题。

![](/img/g1.webp)

使用 G1 收集器时，Java 堆的内存布局与其他收集器有很大区别，整个 Java堆 会被划分为多个大小相等的独立区域 Region，新生代和老年代不再是
物理隔离，都是一部分的Region的集合。G1 会跟踪各个 Region 的垃圾收集情况（回收空间大小和回收消耗时间），维护一个优先列表，根据允许的
收集时间，优先回收价值更大的 Region，避免在整个 Java堆上进行全区域的垃圾回收，确保了G1 收集器可以在有限的时间内尽可能收集更多的垃圾。

mixed gc:   
当越来越多的对象晋升到老年代 old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 mixed gc。该算法
并不是一个old gc，除了回收整young region，还会回收一部分的 old region，可以选择哪些 old region 进行收集，从而可以对
垃圾回收的耗时时间进行控制。

mixed gc的执行过程类似于 cms，主要为：
1. initial mark: 初始化标记过程，整个过程 stop-the=world，标记了 GC Roots 可达的对象
2. concurrent marking: 并发标记对象，整个过程 gc collector 线程与应用程序可以并行执行，标记出 GC Root 可达对象衍生出去
的存活对象，并收集各个 Region 的对象信息。
3. remark: 最终标记过程，整个过程 stop-the-world，标记出那些并发标记过程中遗漏的，或者内部引用变化的对象
4. clean up: 垃圾清理过程，如果发现一个 Region 中没有存活的对象，则把该 Region 加入到空闲列表中

G1 优点：  
1. 并行与并发：充分利用多 CPU 来缩短 Stop the world 的停顿时间
2. 分代收集：不需要其他收集器配合就可以管理整个 Java 堆，采用不同的方式处理新建的对象、已经存活一段时间和经历多次 GC 的对象获取更好
的收集效果。
3. 空间整合：与 CMS 的 “标记-清除”算法不同，G1 在运行期间不会产生内存空间碎片，有利于应用的长时间运行，且分配大对象时，不会导致由于
无法申请到足够大的连续内存而提前触发一次 Full GC
4. 停顿预测：G1 中可以建立可预测的停顿模型，能让使用者明确指定在 M 毫秒的时间片段内，消耗在垃圾收集器上的时间不得超过 N 毫秒


使用G1 收集器时，一个对象分配在 Region 中，可以和Java 堆上任意的对象有引用关系，如何判定一个对象的存活，是否需要扫描整个Java 堆？

G1 收集器中的 Region 之间的对象引用关系和其他收集器中的新生代和老年代之间的对象引用关系被保存在 Remembered Set中，当虚拟机发现
程序对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于相同的 Region
中，如果不是，则通过 CardTable 把相关引用信息记录到被引用对象所属Region 的 Remembered Set 中。

### 引用
[Java GC的那些事（1）](https://www.jianshu.com/p/6d1cbe38a54b)  
[Java GC的那些事（2）](https://www.jianshu.com/p/94989b278114)  
[杂谈GC](https://www.jianshu.com/p/2750c7c202ef)  