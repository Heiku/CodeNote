# 小册内容



## InnoDb 记录结构

1. char(n) : 会用 __空白字符__ 填充存储字段
2. __行溢出__: 例如 `varchar` ，因为受限于数据页的大小只有 16K，所以如果存储的字段过大，可能会导致数据单页中无法存下字段数据，所以会先 ___存储一部分__， 然后再记录其他部分的地址 (Compact 格式)，而 5.7 以后采用的 (Dynamic) 则是将所有真实数据存储到其他页面中。





## B+ 树索引的使用

1. 如果在聚合索引中 `idx(name, birthday, phone_number)` 中，如果我们在查询的时候使用 `select * from t where name > Asa and name < bar and birthday > '1997-01-01'` 时，这时候只能使用到聚合索引中的 `name`，而这个查询中通过 `name`进行范围查找的记录中可能并不是按照 `birthday` 列进行排序的（排序的只是 name 相同的值），所以需要对所有经过 idx(name) 筛选后的结果进行过滤。

   如果采用精确匹配，才会走联合索引的全部字段 `select * from t where name = ? and birthday = ? and phone_number > 111111;`

2. 使用 order 的时候，可以借助聚合索引减少排序的性能消耗





## InnoDB 的表空间

1. 数据存放在 __页__ 上，每 64 个页组成 __区(extent)__，即每个区的大小为 16KB * 64 = 1MB，每 256 个 extent  形成一组

2. __extent__：想象一下，`B+` 树中每一层都是多个页组成的双向链表，如果我们以 `页` 作为单位分配存储空间，双向链表相邻的两个页之间的物理位置可能离得非常远（区分一下 `预读`：预读指的是在读取加载数据的时候，会因为局部缓存原理将相邻的数据块载入读取，而这里的数据页是物理不相邻的），这样会产生大量的 `随机IO`，所以我们应该让  __链表中相邻的页的物理位置也相邻__ ，这样在范围查询的时候才能使用到 `顺序IO`。

3. __segment__：在范围查询中，如果区分非叶子节点和叶子节点，统统把节点的页全放到申请的区，范围查询的效果大大折扣，所以需要将叶子节点和非叶子节点进行物理的再次区分，存放叶子节点的集合为 `叶子节点段`，非叶子节点的集合为 `非叶子节点段`。也就是说，一个索引会生成两个 `segment`。

4. __fragment__：已知一个索引表会分为两个 __段__，而段又是以 __区__ 作为分配大小，也就是说，一个表至少要占用2M的数据大小，这对于小表的话存储空间不友好，所以在表的起步阶段（建表后数据量小），会在 __碎片区(fragment)__ 中存储某些属于 __叶子节点段的页面__ 和 __非叶子节点段的页面__，甚至有些页面哪个段都不属于（相当于在数据量小的时候，划分页的时候从公共的存储空间 fragment 中划分，当某个段已经占据 32 个碎片区页面后，就会以完整的区作为单位划分存储空间）。

   

* 链表小结

  表空间是由若干个区组成的，每个区对对应一个 `XDES Entry` 结构，直属于表空间的区（数据小）对应的 `XDES Entry` 结构可以分成 `FREE`、`FREE_FRAG`、`FULL_FRAG` 这三个链表；每个段可以附属于若干个区（数据大），每个段中的区对应的 `XDES Entry` 结构可以分成 `FREE`、`NOT FULL`、`FULL` 这三个链表。每个链表都对应一个 `List Base Node` 的结构，这个结构记录了链表的 头、尾节点的位置以及该链表中包含的节点数（方便管理区空间）。





## 单表的访问方法

* const：等值查询（主键或者唯一索引）
* ref：等值查询（普通二级索引，因为可能存在多条数据，需要回表查询的数据量可能比较大）
* ref_or_null：等值查询（和 `ref` 差不多，只是多了个 is NULL 的 NULL 值匹配）
* range：范围查询（包括主键索引和二级索引）
* index: 覆盖索引（不需要回表）
* all：全表扫描



## 索引合并

### 合并（Intersection）

```
// 先去索引A 查找筛选的 `id` 集合，然后再去索引C 查找筛选的 `id` 集合，最后查找交集回表查找行记录。
select * from t where key1 = `a` and key3 = `b`;
```

虽然读取多个二级索引比读取一个二级索引消耗性能，但读取二级索引的时候是 `顺序IO`，而回表的时候，根据主键查找主键索引数却是 `随机IO`，这样经过筛选后的 id 更少，需要回表的数据更少，也就是说会减少可能产生的 `随机IO`。



索引合并的条件：

1. 二级索引列时等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能只匹配部分列的情况

2. 主键列可以是范围匹配

为什么会需要这两个条件呢？

* 因为无论是 __二级索引范围查询__ 还是 __联合索引非全部等值匹配__，每种情况都会出现返回的结果主键 id 集合是 __无序的__ ，对于无序的主键 id 集合，还需要进行排序后才能查找交集，这样的存在性能损耗，还不如直接单一索引返回集回表再过滤。



### 合并 (Union)

```
select * from t where key = `a` or key3 = `c`;
```



合并情况：

1. 二级索引列是等值匹配的情况，对于联合索引来说，再联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况
2. 主键列可以是范围匹配
3. 使用 `intersection` 索引合并的搜索条件



### Sort-Union 合并

```
select * from t where key1 < 'a' or key3 > 'z';
```

搞特殊，将两个索引的范围查找后的 id 结果集进行 __排序__ 后，然后取并集再回表。



为什么会有 Sort-Union 而没有 Sort-Intersection 呢？

* Sort-Union 的适用场景是单独根据搜索条件从二级索引中获取的记录数比较少，这样对搜索后结果排序的成本不会太高。（其实就是说因为要满足 or 的语义，所以我们不能像 intersection 一样单独拿一个搜索后的结果回表再过滤另一个条件，所以为了尽量减少回表的开销，还是要尽量二级索引树得到最终的筛选 id 结果集，所以采用了排序再取并集的方法得到结果集。）
* Intersection 索引的适用场景是单独根据搜索条件从二级索引中获取记录数太多，导致回表的开销太大，合并后可以明显降低回表开销，但如果加入 Sort-Intersection 之后，需要为大量的二级索引按照主键值进行排序，成本可能比回表都高。





## 连接的原理



### 内连接

__内连接__ 和 __外连接__ 的根本区别是在驱动表中的记录不符合 `on` 子句的连接条件时，不会把该记录加入到最后的结果集中。



#### 嵌套循环连接 (Nested-Loop Join)

驱动表筛选后的结果去查被驱动表（如果被驱动表比较大的话，很有可能加载到内存的时候，之前这个表的数据页被淘汰，导致整个过程中需要循环加载淘汰表，效率非常低），被驱动表可能被多次访问（当然，可以考虑使用索引加速访问）。



#### 基于块的嵌套循环连接 (Block Nested-Loop Join)

为了尽量减少访问被被驱动表的次数，使用了 `join buffer` 将驱动表的数据缓存起来，然后经过筛选条件将被驱动表的数据加载到内存的时候，再拿内容中的数据与 `join buffer` 中的缓存结果集进行匹配，最后得到结果。（因为 `join buffer` 的内容有限，所以我们要尽量保证再驱动表中查询的数据量比较小，所以我们要避免 `select *... ` 这种将全字段数据加载到 `join buffer` 中，要指定字段限制一下放入缓存中的数据大小）





## MySQL 基于成本的优化



在连接查询的优化（内连接查询中优化器选取驱动表和被驱动表）：

* 尽量减少驱动表的扇出
* 对被驱动表的访问成本尽量低



### 子查询优化

* in 子查询优化：一般我们的子查询是得到结果集之后，然后与外面的查询进行匹配得到最后结果。而在 `select * from t1 where c1 in (select * ...)` 这类的查询中，MySQL 会进行优化，将结果集 __物化(Materialize)__ 成一个临时表（数据量小时为 Memory 表，基于 Hash 索引，数据量大以至于无法放入到内存中时，采用 B+ 临时表的方式），在查询的时候再进行扫描取出 column 的参数与结果集进行匹配。（这个过程中因为时多个表，所以也会经过优化器进行分析判断，判断成本低的表作为驱动表（io成本-加载读取数据页， cpu成本-对行数据进行条件判断），内连接优化处理）
* 为什么要物化呢？如果结果集过大，那么会导致在查询的时候 in(many....)，会转化成 or A or B .... 多个or进行拼接，在判断的时候效率比较低，所以不如直接建立一个索引，直接查索引看是否匹配（牺牲一点空间转化成效率）。



#### semi-join

```
SELECT * FROM s1 WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a');

// 转化成连接的方式
SELECT s1.* FROM s1 INNER JOIN s2 ON s1.key2 = s2.key2 WHERE s2.key3 = 'a';
```

* 如果子查询的结果集主键值或唯一索引时，直接转换
* 如果返回的结果集会重复，那么建立临时表（只有id这一列），与外查询匹配的结果集会添加到这个临时表中，如果添加失败，说明出现重复的值，那么直接丢弃当前这个匹配值。





## Explain 详解

```
mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL                                  |
|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
2 rows in set, 1 warning (0.01 sec)
```



* id：每个 `select` 都对应一个唯一的 id 值，仅在 `union union all` 或者 `子查询 subquery` 中会出现多个 select 关键字，这时才会有字段区分，如果时连接查询会使用同一个 id 值



* select type:
  * simple: 不包含 `union` 和 `子查询`
  * primary：对于包含 `union` 、`子查询` 这类大查询中的最左的查询语句
  * union：使用了 `union`、`union all`，除了最左边的大查询，其他都是 union 查询
  * union_result: MySQL 选择使用临时表完成 `union` 的查询去重工作
  * subquery：包含子查询的查询语句不能转为对应的 `semi-join（连接查询操作）`，并且改子查询是 __不相关子查询__，并且查询优化器决定采用将该子查询 __物化__ 的方案进行
  * dependent subquery：包含子查询的查询语句不能转换成 `semi-join`，并且该子查询是 __相关子查询__
  * dependent union：在包含 `union union all` 的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余小查询都是
  * derived：对于采用 __物化__ 的方式执行包含派生表的查询（仅对物化的表进行查询）
  * materialzed：当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询（物化表与外层字段查询进行匹配）



* type：

  * system：表中由精确数据，例如 `count(*)` 在 Memory、MyISAM
  * const：根据 __主键__ 或 __唯一二级索引__ 与常数进行等值匹配
  * eq_ref：在连接查询中，如果被驱动表是通过 __主键__ 或 __唯一二级索引__ 列等值匹配的方式进行访问（如果是联合索引的话，需要全匹配同时也要满足最重要的唯一性）
  * ref：通过普通的二级索引列与常量进行等值匹配时
  * ref_or_null：对普通二级索引进行等值匹配查询，该索引值也可以是 `NULL`
  * index_merge：一般情况下对某个表只能使用到一个索引，但在单表访问的情况下可以使用 `intersection`、`Union`、`Sort-Union` 这三种 [索引合并](#索引合并) 的方式执行查询
  * union_subquery：类似于两表连接中被驱动表的 `eq_ref` 访问方法，`union_subquery` 是针对在一些包含 `in` 子查询的语句中，如果查询优化器决定将 `in` 子查询优化成 `exists` 子查询，并且子查询可以使用到主键进行等值匹配
  * index_subquery：与 `union_subquery` 类似，只不过访问子查询中的表时使用的时普通的索引
  * range：使用索引获取 `范围区间` 的记录
  * index：可以使用覆盖索引，但需要 __扫描全部的索引记录__（extra 字段中也会通知 using index，注意判断是否扫描全部索引数据）
  * all：全表扫描

  

* possible_keys、key

  * possible_keys：表示某个查询语句中，对某个表执行单表查询时可能使用到的索引有哪些（注意：并不是 possible_keys 越多月好，越多的话可能会导致查询优化器在 __计算成本__ 的时候代价更大）
  * key：表示经过查询优化器，最终使用的索引



* key_len

  表示当优化器决定使用某个索引执行查询的时候，该索引记录的最大长度（ __实际使用索引字段的长度__，如果时联合索引的话，只记录使用到的某个字段 或 全部字段的长度，所以我们可以通过这个字段判断联合索引中哪些字段使用到了索引，哪些没有）



* ref

  当使用索引列等值匹配的条件去执行查询时，也就是执行方法是 `const`、`eq_ref`、`ref`、`ref_or_null`、`unique_subquery`、`index_subquery`时，ref 列展示的就是索引列等值匹配的类型是啥

  ```
  mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;
  +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+
  | id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref             | rows | filtered | Extra |
  +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+
  |  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL            | 9688 |   100.00 | NULL  |
  |  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xiaohaizi.s1.id |    1 |   100.00 | NULL  |
  +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+
  2 rows in set, 1 warning (0.00 sec)
  ```



* rows

  预计扫描的记录行数



* filtered

  MySQL 在计算驱动表扇出(fanout 即对被驱动表执行查询的次数)

  ```
  mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = 'a';
  
  rows | 	filtered
  9688 |  10.00
  1 	 |  100.00
  
  那么 s1 计算的扇出值为 9688 * 10% = 968，说明对被驱动表要执行 968 次查询
  ```



* extra：
  * using index condition：索引条件下推，如果使用到了这个索引后，后续的条件虽然不能走索引，但可以根据索引得到的结果进行判断 `key > a and key likes %a` ，减少了回表判断带来的随机IO
  * 