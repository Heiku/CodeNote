## 小册内容



### InnoDb 记录结构

1. char(n) : 会用 __空白字符__ 填充存储字段
2. __行溢出__: 例如 `varchar` ，因为受限于数据页的大小只有 16K，所以如果存储的字段过大，可能会导致数据单页中无法存下字段数据，所以会先 ___存储一部分__， 然后再记录其他部分的地址 (Compact 格式)，而 5.7 以后采用的 (Dynamic) 则是将所有真实数据存储到其他页面中。



### B+ 树索引的使用

1. 如果在聚合索引中 `idx(name, birthday, phone_number)` 中，如果我们在查询的时候使用 `select * from t where name > Asa and name < bar and birthday > '1997-01-01'` 时，这时候只能使用到聚合索引中的 `name`，而这个查询中通过 `name`进行范围查找的记录中可能并不是按照 `birthday` 列进行排序的（排序的只是 name 相同的值），所以需要对所有经过 idx(name) 筛选后的结果进行过滤。

   如果采用精确匹配，才会走联合索引的全部字段 `select * from t where name = ? and birthday = ? and phone_number > 111111;`

2. 使用 order 的时候，可以借助聚合索引减少排序的性能消耗



### InnoDB 的表空间

1. 数据存放在 __页__ 上，每 64 个页组成 __区(extent)__，即每个区的大小为 16KB * 64 = 1MB，每 256 个 extent  形成一组

2. __extent__：想象一下，`B+` 树中每一层都是多个页组成的双向链表，如果我们以 `页` 作为单位分配存储空间，双向链表相邻的两个页之间的物理位置可能离得非常远（区分一下 `预读`：预读指的是在读取加载数据的时候，会因为局部缓存原理将相邻的数据块载入读取，而这里的数据页是物理不相邻的），这样会产生大量的 `随机IO`，所以我们应该让  __链表中相邻的页的物理位置也相邻__ ，这样在范围查询的时候才能使用到 `顺序IO`。

3. __segment__：在范围查询中，如果区分非叶子节点和叶子节点，统统把节点的页全放到申请的区，范围查询的效果大大折扣，所以需要将叶子节点和非叶子节点进行物理的再次区分，存放叶子节点的集合为 `叶子节点段`，非叶子节点的集合为 `非叶子节点段`。也就是说，一个索引会生成两个 `segment`。

4. __fragment__：已知一个索引表会分为两个 __段__，而段又是以 __区__ 作为分配大小，也就是说，一个表至少要占用2M的数据大小，这对于小表的话存储空间不友好，所以在表的起步阶段（建表后数据量小），会在 __碎片区(fragment)__ 中存储某些属于 __叶子节点段的页面__ 和 __非叶子节点段的页面__，甚至有些页面哪个段都不属于（相当于在数据量小的时候，划分页的时候从公共的存储空间 fragment 中划分，当某个段已经占据 32 个碎片区页面后，就会以完整的区作为单位划分存储空间）。

   

* 链表小结

  表空间是由若干个区组成的，每个区对对应一个 `XDES Entry` 结构，直属于表空间的区（数据小）对应的 `XDES Entry` 结构可以分成 `FREE`、`FREE_FRAG`、`FULL_FRAG` 这三个链表；每个段可以附属于若干个区（数据大），每个段中的区对应的 `XDES Entry` 结构可以分成 `FREE`、`NOT FULL`、`FULL` 这三个链表。每个链表都对应一个 `List Base Node` 的结构，这个结构记录了链表的 头、尾节点的位置以及该链表中包含的节点数（方便管理区空间）。



### 单表的访问方法

* const：等值查询（主键或者唯一索引）
* ref：等值查询（普通二级索引，因为可能存在多条数据，需要回表查询的数据量可能比较大）
* ref_or_null：等值查询（和 `ref` 差不多，只是多了个 is NULL 的 NULL 值匹配）
* range：范围查询（包括主键索引和二级索引）
* index: 覆盖索引（不需要回表）
* all：全表扫描



#### 索引合并

##### 合并（Intersection）

```
// 先去索引A 查找筛选的 `id` 集合，然后再去索引C 查找筛选的 `id` 集合，最后查找交集回表查找行记录。
select * from t where key1 = `a` and key3 = `b`;
```

虽然读取多个二级索引比读取一个二级索引消耗性能，但读取二级索引的时候是 `顺序IO`，而回表的时候，根据主键查找主键索引数却是 `随机IO`，这样经过筛选后的 id 更少，需要回表的数据更少，也就是说会减少可能产生的 `随机IO`。



索引合并的条件：

1. 二级索引列时等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能只匹配部分列的情况

2. 主键列可以是范围匹配

为什么会需要这两个条件呢？

* 因为无论是 __二级索引范围查询__ 还是 __联合索引非全部等值匹配__，每种情况都会出现返回的结果主键 id 集合是 __无序的__ ，对于无序的主键 id 集合，还需要进行排序后才能查找交集，这样的存在性能损耗，还不如直接单一索引返回集回表再过滤。



##### 合并 (Union)

```
select * from t where key = `a` or key3 = `c`;
```



合并情况：

1. 二级索引列是等值匹配的情况，对于联合索引来说，再联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况
2. 主键列可以是范围匹配
3. 使用 `intersection` 索引合并的搜索条件



###### Sort-Union 合并

```
select * from t where key1 < 'a' or key3 > 'z';
```

搞特殊，将两个索引的范围查找后的 id 结果集进行 __排序__ 后，然后取并集再回表。



为什么会有 Sort-Union 而没有 Sort-Intersection 呢？

* Sort-Union 的适用场景是单独根据搜索条件从二级索引中获取的记录数比较少，这样对搜索后结果排序的成本不会太高。（其实就是说因为要满足 or 的语义，所以我们不能像 intersection 一样单独拿一个搜索后的结果回表再过滤另一个条件，所以为了尽量减少回表的开销，还是要尽量二级索引树得到最终的筛选 id 结果集，所以采用了排序再取并集的方法得到结果集。）
* Intersection 索引的适用场景是单独根据搜索条件从二级索引中获取记录数太多，导致回表的开销太大，合并后可以明显降低回表开销，但如果加入 Sort-Intersection 之后，需要为大量的二级索引按照主键值进行排序，成本可能比回表都高。