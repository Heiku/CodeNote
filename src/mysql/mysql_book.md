### 小册内容



#### InnoDb 记录结构

1. char(n) : 会用 __空白字符__ 填充存储字段
2. __行溢出__: 例如 `varchar` ，因为受限于数据页的大小只有 16K，所以如果存储的字段过大，可能会导致数据单页中无法存下字段数据，所以会先 ___存储一部分__， 然后再记录其他部分的地址 (Compact 格式)，而 5.7 以后采用的 (Dynamic) 则是将所有真实数据存储到其他页面中。



#### B+ 树索引的使用

1. 如果在聚合索引中 `idx(name, birthday, phone_number)` 中，如果我们在查询的时候使用 `select * from t where name > Asa and name < bar and birthday > '1997-01-01'` 时，这时候只能使用到聚合索引中的 `name`，而这个查询中通过 `name`进行范围查找的记录中可能并不是按照 `birthday` 列进行排序的（排序的只是 name 相同的值），所以需要对所有经过 idx(name) 筛选后的结果进行过滤。

   如果采用精确匹配，才会走联合索引的全部字段 `select * from t where name = ? and birthday = ? and phone_number > 111111;`

2. 使用 order 的时候，可以借助聚合索引减少排序的性能消耗



#### InnoDB 的表空间

1. 数据存放在 __页__ 上，每 64 个页组成 __区(extent)__，即每个区的大小为 16KB * 64 = 1MB，每 256 个 extent  形成一组
2. extent：想象一下，`B+` 树中每一层都是多个页组成的双向链表，如果我们以 `页` 作为单位分配存储空间，双向链表相邻的两个页之间的物理位置可能离得非常远（区分一下 `预读`：预读指的是在读取加载数据的时候，会因为局部缓存原理将相邻的数据块载入读取，而这里的数据页是物理不相邻的），这样会产生大量的 `随机IO`，所以我们应该让  __链表中相邻的页的物理位置也相邻__ ，这样在范围查询的时候才能使用到 `顺序IO`。