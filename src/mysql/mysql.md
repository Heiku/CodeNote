
### 引用
[MySQL的InnoDB索引原理详解](https://kyle.ai/blog/6439.html)  
[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)  
[MySQL索引原理及慢查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)  
[高性能 MySQL]()  

### 磁盘I/O

影响磁盘得关键因素是磁盘服务时间，它由寻道时间、旋转延迟、数据传输时间三部分构成。  
衡量指标：  
IOPS（Input/Output Per Second）：每秒的输入输出量（读写次数），即指每秒内系统能处理的I/O请求数量。  
吞吐量（Throughput）：指单位时间内可以成功传输的数据数量

1. 寻道时间  
寻道时间是指读写磁头移动到正确的磁道上所需要的时间。寻道时间越短，I/O操作越快，目前磁盘的平均寻道时间一般在3s - 15ms。因为寻道比较耗时，设计时往往
要减少磁盘的随机I/O 次数。

2. 旋转延迟
旋转是盘片旋转将请求数据所在的扇区移动到读写磁盘下方所需要的时间。旋转延迟取决于磁盘转速，通常用磁盘旋转一周所需的时间的 1/2 表示。大概2-5ms

3. 数据传输时间
数据传输时间是指完成传输所请求的数据所需要的时间，它取决于数据传输率，其值等于数据大小 / 数据传输率，数据传输率和磁盘的读取率有关。


#### PageCache

PageCache 在操作系统和磁盘之间，主要用来缓存磁盘中的数据，这样可以提高磁盘的访问效率，缺点是当断电的时候可能会导致数据不一致的情况。

在 Linux 实现中，文件 Cache 分为两个层面：
* Page Cache: 用来作为文件系统上的文件数据的缓存来用，尤其是针对当进程对文件有 read/write 操作的时候。
* Buffer Cache: 用来在系统对块设备进行读写的时候，对块进行数据缓存的系统来使用。

磁盘 Cache 的主要两大功能：预读与回写
* 预读：利用局部性原理，具体过程是：对于每个文件的第一个读请求，系统读入所请求的页面，并读入紧随着的的少数几个页面（大概3个，组成4k），这时的预读称为
同步预读。对于第二次读请求，如果所读的页面不再 Cache 中，即不再预读的页中，表明文件访问不是顺序访问，系统继续采用同步预读。如果所读的页面在 Cache中，
则表明前次预读命中，操作系统把预读页的大小扩大一倍，此时预读过程是异步的，应用程序可以不等预读完成即可返回，只要后台慢慢读页面就行，这个过程称为异步预读。

* 回写：通过暂时将数据存在 Cache 里，然后异步写道磁盘中，通过这种异步的数据I/O模式解决了程序中的计算速度和数据存储速度不匹配的鸿沟，
减少了访问底层存储介质的次数，使存储系统的性能大大提高。


tips：  
1，采用追加写，每次将数据添加到文件中，由于使顺序写入，减少了磁头移动和旋转的时间，所以性能很好。但实现起来有些困难，因为写入的过程中，伴随着合并I/O操作，
在进行批量提交尽量实现回写。

2.文件合并和元数据的优化（TFS）。将小文件合并成大文件后，首先减少了大量的元数据，提高了元数据的检索访问效率，减低了文件读写的I/O操作延时。
其次将可能连续访问的的小文件合并存储，提高了文件之间的局部性，将原本小文件的随机访问变成了顺序访问，大大提高了性能。同时，合并存储能有效的减少小文件
存储时产生的磁盘碎片化问题，提高了磁盘的利用率。最后，合并之后小文件的访问流程也有了很大的变化，由原来的许多 open 操作变成了 seek ，定位到大文件具体
位置即可。但带来的是额外的索引设计，往往需要额外维护一个索引文件记录关键的元数据信息，主要为偏移和文件大小。

扇区 & 磁盘块 & 页

* 扇区：磁盘的最小存储单位，512byte
* 磁盘块：一个磁盘块由连续几个（2^n）扇区组成，通常4K
* 页： 内存的最小存储单位，页的大小为磁盘块的 2^n 倍，通常4K 

### 范式

* 1NF: 字段是最小的单位，不可再分  
* 2NF: 消除非主属性对码的部分依赖（要有主键，要求其他字段依赖主键）  
* 3NF: 消除非主属性对码的传递依赖（非主键外的所有字段必须互不依赖）
* 4NF: 满足 3NF, 消除表中的多值依赖

### 数据类型

char vs varchar

* varchar: 存储可变长的字符串，除了存储字符串str， 还额外使用 1/2 个字节存储字符串的长度，所以比定长字符串更节省空间，因为只使用了必要的空间。

    但在 UPDATE 的时候，由于行的变长，有可能导致页内没有空间可以存储，这种情况下，InnoDB 需要进行分裂页使得行可以放入页内
    
* char: 存储定长得字符串，采用填充空格得方式补充预定义得存储空间，非常适合存储一些定长得字符串例如（MD5值， BASE64编码字符串）

tips：所以在存储字符串到 char 得时候，如果有空格在字符串得左右边界得时候，会被忽略，而 varchar 则不会。当然最好还是一次性指定完字符串分配空间得大小，
      因为慷慨得给更长得字符串长度会占用更多得内存空间  
      还得注意一点：因为 SHA1(), MD5(), UUID()产生的字符串会分布在很大的空间内，局部缓存原理将导致 INSERT/SELECT 变得很慢，
      所以作为标识符的时候，尽量使用 int 代替 char
<br>


BLOB vs TEXT

都是为了存储大数据而设计得字符串数据类型，区别在于 BLOB 二进制存储，而 TEXT 以字符串方法存储  
与其他类型不同得是，当 BLOB 与 TEXT 的值太大的时候，InnoDB 会使用额外的空间存储字段值，并在原先的字段上使用1-4字节的指针指向对应的存储空间


DATETIME vs TIMESTAMP

DATETIME: 存储格式 ANSI 标准下的日期定义 "2019-11-15 16:59:50"
TIMESTAMP: 存储格式为 UNIX 时间戳，建议使用，因为更加节省存储空间



### 数据结构

树形结构：

* 搜索二叉树：每个节点有两个子节点，数据量的增大会导致高度的增加，查询的路径更长，更耗时，不能作为大量数据的存储结构
* B树：一棵 m 阶B树是一棵平衡的 m 路搜索树。最重要的性质是每个非根节点所包含的关键字个数j满足：m/2 - 2 <= j <= m - 1，即一个子节点的数量会比关键字多1，  
    这样关键字成了子节点的分割标志。__由于数据会同时存在于叶子节点和非叶子节点，无法简单遍历B树中的关键字，必须采用中序遍历的方法。__
* B+树：特性是每个非根节点所包含的关键字个数j满足：m/2 - 1 <= j <= m，子树的个数最多可以和关键字一样，非叶子节点存储的是子树的最小关键字，  
    __同时数据节点只存在于叶子节点，且叶子节点增加了横向的指针，这样顺序遍历所有数据将变得容易__
* B*树：特性是每个非根节点所包含的关键字个数j满足：m2/3 -1 <= j <= m，同时 __非叶子节点之间增加了横向指针__




### 粗盘存储原理

为什么会选择B+树？

一般而言，索引本身是很大的，无法全部存储在内存中，因此索引通常以索引文件的方式存储在磁盘中，而读取磁盘文件的时候就会产生磁盘IO消耗，所以评定一个
数据结构适不适合作为索引的标准就是索引过程中的磁盘I/O操作次数的渐进复杂度。

与主存（RAM 随机读写存储器）不同，磁盘I/O存在机械运动：寻道时间 + 旋转延迟 + 传输时间

#### 局部性原理 & 磁盘预读

受限于存储介质，磁盘的存取本身就比主存慢很多，加上磁盘机械运动，效率更低。因此为了提高磁盘的效率，要尽量减少磁盘I/O，所以在磁盘在读取的时候，
每次都会 __预读__，即使读取的内容很少，也会额外读取一定长度的数据放入到内存中。

局部性原理： 当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到

预读的的长度一般为页（page）的整数倍。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割成为连续大小相等块，每一块存储块为一页（4K），
主存和磁盘以页为单位交换数据，当程序要读取的数据不在主存的时候，会产生一个缺页中断，此时系统会向磁盘发起读磁盘信号，磁盘会找到数据的起始位置并向后连续
读取一页或几页载入到内存中，然后异常返回，程序继续运行。

### 分析

根据B+ 树的定义，每个节点内部都会有多个子节点(关键字)。对于Mysql，每一个节点就是一个数据块(和页大小相同),每个节点只需要一次I/O就可以完全载入
这时，从根节点找到子节点的时候就需要发生3次磁盘I/O。3层的B+ 树可以表示百万的数据量，在这些数据量中查找数据仅需3次磁盘I/O是很可观的。

假设当前表的数据为N， 每个磁盘块的数据项的数量为m，则有 h=㏒(m+1)N，  
也就是说，当数据量N 一定的情况下，m越大，h越小。  
而数据量数量m = 磁盘块大小 / 数据项大小，而磁盘块大小也就是数据页的大小是固定的，所以得减小数据项（字段要尽量小），数据项数量m增大，高度h才会降低

而使用红黑树结构，树高h 通常会深很多，由于逻辑上的很近的父子节点，在物理存储上可能很远，无法利用局部性原理，所以红黑树的I/O 复杂度为O（h），性能差



### 索引

#### 聚簇索引

聚簇索引 是一种数据存储方式，当表有聚簇索引的时候，数据行实际上存放在索引的叶子页上。因为无法同时将数据行放在两个不同的地方，  
所以一个表只能有一个聚簇索引。（主键值，事务ID，MVCC回滚指针，数据列信息）

优点：
* 可以把相关的数据保存在一起，例如如果以用户id为主键，那么索引过程中用户的数据可以通过读取少量的磁盘页实现，否则将导致多次的磁盘IO
* 数据访问更快，因为聚簇索引将数据行和索引放在同一棵 B+ Tree，因此获取数据的时候会比非聚簇索引更快
* 使用覆盖索引扫描可以直接使用页节点中的主键值

缺点：
* 插入的速度严重依赖于插入的顺序，如果按照主键的顺序插入，将是最快的方式。如果不是的话，最好插入后 OPTIMIZE TABLE 重新组织表结构
* 更新聚簇索引的代价很高，因为插入新的数据会将每个被更新的数据行移动到新的位置
* 当插入数据的时候，有可能面临 “页分裂”，当行的主键值要求插入到某个已满的页中，存储引擎会将页分裂成两个页面来容纳该行，  
    页分裂会导致表占用更多的磁盘空间

聚簇索引下分为主键索引和辅助索引：

* 主键索引：行数据和主键 B+ 存储在一起，相当于一个表。
* 辅助索引：辅助键B+ 树只存储辅助键和主键

#### 非聚簇索引：

非聚簇索引存储：主键B+ 树在叶子节点存储真正指向数据行的指针，而非主键，辅助树叶子节点也一样存储指向数据行的指针，即多张索引B+ 树都是指向同一个表空间

#### 二级索引（辅助索引）

与主键索引相比，查找的时候需要访问两次 B+ Tree，因为默认的 B+Tree 的叶子节点保存具体的数据行，而是行的主键值。这意味着，如果要查找行，  
存储引擎需要先找到二级索引的叶子节点获取对应的主键值，然后根据这个值去聚簇索引的 B-Tree找到对应的行  
（采用自适应哈希索引能减少这样的重复工作）

e.g.:

* Innodb: 将主键组织到一棵B+ 树中，而数据行就存在对应的叶子节点上。当索引“where id = 1”时，会按照主键索引，直接在主键B+ 树上找到对应的叶子节点，
即具体的数据行。而我们索引“where name = “Jane”，会先从辅助索引B+ 树上找到对应 name 的叶子节点（主键值），然后再通过主键值再主键索引B+ 树上索引
最终的数据行信息。

* MyISM: （和上面相同的例子）非聚簇索引的两棵B+ 树和聚簇索引结构上没什么区别，区别在于叶子节点存储了一个地址指向真正的表数据，由于索引树是独立的，
通过辅助键检索无需访问主键的索引树，因为都可以再叶子节点指向真正表空间中的数据行


为什么使用聚簇索引呢？（看起来要查多次索引B+ 树）

1. 因为主键索引树上行数据和叶子节点存储在一起，那么在载入数据的时候就包括了主键和行数据，如果主键查找，找到对应叶子节点就可以直接放回数据了。
2. 辅助索引中使用主键而不是地址指针的好处是，减少了当前行移动或者是数据分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多空间，
但换来的是，当 Innodb 在移动行的时候无需更新辅助索引中的 “指针”，行的位置会随着数据库中的数据修改而变化（B+树分裂 / 页空间满导致的页分裂）


为什么Innodb 在插入数据的时候最好选择自增主键数据？

因为Innodb 采用的是聚簇索引，维护了一棵主键索引树，当主键有序时，可以按顺序插入到页空间，当页空间满时，重新分配页空间继续插入。
* 写入目标页可能已经刷到磁盘上并从缓存中移除，或者是还没被加载到缓存中，InnoDB 在插入之前不得不先从磁盘读取目标页到内存中，导致大量随机I/O
* 因为乱序写入，InnoDB 不得不频繁地做页分裂操作，以便为新的行分配空间，页分裂会导致移动大量数据，一次插入操作至少修改三个页
* 由于频繁的页分裂，页会变得稀疏并被不规则填充，所以最终数据会有碎片化。

为了防止出现大量碎片化，可以在插入后，OPTIMIZE TABLE 重建表并优化页的填充


### 什么是全文索引（fulltext index）？

简单概括来说就是对 `非结构化数据`（不定长且无固定格式的数据）对其建立索引的过程。  
例如我们当我们需要从邮件、日志等大数据量的文本检索某个词的时候，一般只能顺序遍历扫描查找，但这样的效率很低，
所以就需要一种能够根据索引找到对应数据的方法。  
这就是倒排索引，先对数据进行分词分析，对关键词进行记录，找到对应的位置等信息，通过一个映射表（联想词典）映射索引位置关系。

MyISAM 的全文索引是一棵特殊的B- Tree索引，共两层，第一层是关键字，然后第二层是一组“文档指针”，通过过滤词过滤词语分词建立索引树。

MySQL中的倒排索引是基于红黑树实现的，同时Mysql的全文索引效率不高，因为存储结构为B+，导致在写入数据的时候非常消耗IO，序的过程中需要移动节点.



### 查询的总过程

1. MySQL 通信协议处理（用户认证，结果集返回等）
2. 查询缓存
3. 查询语句解析（通过MySQL 将SQL 语句进行解析，生成一棵对应的“解析树”，进行语法验证和解析查询）  
    语法优化： 静态优化（直接对解析树进行分析，完成优化） 和 动态优化 （与查询的上下文有关，需要在每次查询的时候进行评估）
4. 查询存储引擎：将执行计划（语法树数据结构）调用交由对应得存储引擎实现
5. 结果返回：这个结构返回是增量，逐步得，可立即响应且不占据服务端太多内存。同时，会将部分查询结果缓存。

### 排序

当没有使用到索引排序，MySQL需要自己进行排序。
* 如果数据量小则在内存中进行（小于排序缓冲区），MySQL在内存中进行“快速排序”
* 如果数据量大的时候则需要使用到磁盘排序（文件排序 fileSort），先将数据分块，对每个独立的块使用 “快速排序” 进行排序，并将各个块的排序结果保存在磁盘上，
然后将各个排序号的块在进行 merge。最后返回排序结果 

### 设计

如果维护一个自增的数据？

bad: table（cint），每次更新数据的时候都会 update set cint = cint + 1，这样存在的问题是，当并发量高得时候，因为会锁住对应得数据行，  
     所有得请求将会变成串行，导致并发量不高。
     
great: table 中维护 n 个 (cint, slot)，每次更新得时候 mod n，找到对应得 slot 数据行得cint 进行更新操作，  
        在计算总和得时候，sum(all)
        
        


### 操作

alter table？

alter table 的方法是是用新的结构创建一个新的空表，然后从旧表中的数据插入到新表中，然后删除旧表。  
这个操作会导致服务不可用，所以通常做法是将在不提供服务的数据库中操作，然后提供服务的数据库进行切换