


[MySQL的InnoDB索引原理详解](https://kyle.ai/blog/6439.html)


### 范式

* 1NF: 字段是最小的单位，不可再分  
* 2NF: 消除非主属性对码的部分依赖（要有主键，要求其他字段依赖主键）  
* 3NF: 消除非主属性对码的传递依赖（非主键外的所有字段必须互不依赖）
* 4NF: 满足 3NF, 消除表中的多值依赖

### 全文索引：

什么是全文索引（fulltext index）？

简单概括来说就是对 `非结构化数据`（不定长且无固定格式的数据）对其建立索引的过程。  
例如我们当我们需要从邮件、日志等大数据量的文本检索某个词的时候，一般只能顺序遍历扫描查找，但这样的效率很低，
所以就需要一种能够根据索引找到对应数据的方法。  
这就是倒排索引，先对数据进行分词分析，对关键词进行记录，找到对应的位置等信息，通过一个映射表（联想词典）映射索引位置关系。

MySQL中的倒排索引是基于红黑树实现的，同时Mysql的全文索引效率不高，因为存储结构为B+，导致在写入数据的时候非常消耗IO，
排序的过程中需要移动节点.

### 数据类型

char vs varchar

* varchar: 存储可变长的字符串，除了存储字符串str， 还额外使用 1/2 个字节存储字符串的长度，所以比定长字符串更节省空间，因为只使用了必要的空间。

    但在 UPDATE 的时候，由于行的变长，有可能导致页内没有空间可以存储，这种情况下，InnoDB 需要进行分裂页使得行可以放入页内
    
* char: 存储定长得字符串，采用填充空格得方式补充预定义得存储空间，非常适合存储一些定长得字符串例如（MD5值， BASE64编码字符串）

tips：所以在存储字符串到 char 得时候，如果有空格在字符串得左右边界得时候，会被忽略，而 varchar 则不会。当然最好还是一次性指定完字符串分配空间得大小，
      因为慷慨得给更长得字符串长度会占用更多得内存空间  
      还得注意一点：因为 SHA1(), MD5(), UUID()产生的字符串会分布在很大的空间内，局部缓存原理将导致 INSERT/SELECT 变得很慢，
      所以作为标识符的时候，尽量使用 int 代替 char
<br>


BLOB vs TEXT

都是为了存储大数据而设计得字符串数据类型，区别在于 BLOB 二进制存储，而 TEXT 以字符串方法存储  
与其他类型不同得是，当 BLOB 与 TEXT 的值太大的时候，InnoDB 会使用额外的空间存储字段值，并在原先的字段上使用1-4字节的指针指向对应的存储空间


DATETIME vs TIMESTAMP

DATETIME: 存储格式 ANSI 标准下的日期定义 "2019-11-15 16:59:50"
TIMESTAMP: 存储格式为 UNIX 时间戳，建议使用，因为更加节省存储空间



### 操作

alter table？

alter table 的方法是是用新的结构创建一个新的空表，然后从旧表中的数据插入到新表中，然后删除旧表。  
这个操作会导致服务不可用，所以通常做法是将在不提供服务的数据库中操作，然后提供服务的数据库进行切换


### 数据结构

树形结构：

* 搜索二叉树：每个节点有两个子节点，数据量的增大会导致高度的增加，查询的路径更长，更耗时，不能作为大量数据的存储结构
* B树：一棵 m 阶B树是一棵平衡的 m 路搜索树。最重要的性质是每个非根节点所包含的关键字个数j满足：m/2 - 2 <= j <= m - 1，即一个子节点的数量会比关键字多1，  
    这样关键字成了子节点的分割标志。__由于数据会同时存在于叶子节点和非叶子节点，无法简单遍历B树中的关键字，必须采用中序遍历的方法。__
* B+树：特性是每个非根节点所包含的关键字个数j满足：m/2 - 1 <= j <= m，子树的个数最多可以和关键字一样，非叶子节点存储的是子树的最小关键字，  
    __同时数据节点只存在于叶子节点，且叶子节点增加了横向的指针，这样顺序遍历所有数据将变得容易__
* B*树：特性是每个非根节点所包含的关键字个数j满足：m2/3 -1 <= j <= m，同时 __非叶子节点之间增加了横向指针__



### 索引

#### 聚簇索引

聚簇索引 是一种数据存储方式，当表有聚簇索引的时候，数据行实际上存放在索引的叶子页上。因为无法同时将数据行放在两个不同的地方，  
所以一个表只能有一个聚簇索引。（主键值，事务ID，MVCC回滚指针，数据列信息）

优点：
* 可以把相关的数据保存在一起，例如如果以用户id为主键，那么索引过程中用户的数据可以通过读取少量的磁盘页实现，否则将导致多次的磁盘IO
* 数据访问更快，因为聚簇索引将数据行和索引放在同一棵 B+ Tree，因此获取数据的时候会比非聚簇索引更快
* 使用覆盖索引扫描可以直接使用页节点中的主键值

缺点：
* 插入的速度严重依赖于插入的顺序，如果按照主键的顺序插入，将是最快的方式。如果不是的话，最好插入后 OPTIMIZE TABLE 重新组织表结构
* 更新聚簇索引的代价很高，因为插入新的数据会将每个被更新的数据行移动到新的位置
* 当插入数据的时候，有可能面临 “页分裂”，当行的主键值要求插入到某个已满的页中，存储引擎会将页分裂成两个页面来容纳该行，  
    页分裂会导致表占用更多的磁盘空间

聚簇索引下分为主键索引和辅助索引：

* 主键索引：行数据和主键 B+ 存储在一起，相当于一个表。
* 辅助索引：辅助键B+ 树只存储辅助键和主键

#### 非聚簇索引：

非聚簇索引存储：主键B+ 树在叶子节点存储真正指向数据行的指针，而非主键，辅助树叶子节点也一样存储指向数据行的指针，即多张索引B+ 树都是指向同一个表空间

#### 二级索引（辅助索引）

与主键索引相比，查找的时候需要访问两次 B+ Tree，因为默认的 B+Tree 的叶子节点保存具体的数据行，而是行的主键值。这意味着，如果要查找行，  
存储引擎需要先找到二级索引的叶子节点获取对应的主键值，然后根据这个值去聚簇索引的 B-Tree找到对应的行  
（采用自适应哈希索引能减少这样的重复工作）

e.g.:

* Innodb: 将主键组织到一棵B+ 树中，而数据行就存在对应的叶子节点上。当索引“where id = 1”时，会按照主键索引，直接在主键B+ 树上找到对应的叶子节点，
即具体的数据行。而我们索引“where name = “Jane”，会先从辅助索引B+ 树上找到对应 name 的叶子节点（主键值），然后再通过主键值再主键索引B+ 树上索引
最终的数据行信息。

* MyISM: （和上面相同的例子）非聚簇索引的两棵B+ 树和聚簇索引结构上没什么区别，区别在于叶子节点存储了一个地址指向真正的表数据，由于索引树是独立的，
通过辅助键检索无需访问主键的索引树，因为都可以再叶子节点指向真正表空间中的数据行


为什么使用聚簇索引呢？（看起来要查多次索引B+ 树）

1. 因为主键索引树上行数据和叶子节点存储在一起，那么在载入数据的时候就包括了主键和行数据，如果主键查找，找到对应叶子节点就可以直接放回数据了。
2. 辅助索引中使用主键而不是地址指针的好处是，减少了当前行移动或者是数据分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多空间，
但换来的是，当 Innodb 在移动行的时候无需更新辅助索引中的 “指针”，行的位置会随着数据库中的数据修改而变化（B+树分裂 / 页空间满导致的页分裂）


### 设计

如果维护一个自增的数据？

bad: table（cint），每次更新数据的时候都会 update set cint = cint + 1，这样存在的问题是，当并发量高得时候，因为会锁住对应得数据行，  
     所有得请求将会变成串行，导致并发量不高。
     
great: table 中维护 n 个 (cint, slot)，每次更新得时候 mod n，找到对应得 slot 数据行得cint 进行更新操作，  
        在计算总和得时候，sum(all)
        
        
   