### 范式

* 1NF: 字段是最小的单位，不可再分  
* 2NF: 消除非主属性对码的部分依赖（要有主键，要求其他字段依赖主键）  
* 3NF: 消除非主属性对码的传递依赖（非主键外的所有字段必须互不依赖）
* 4NF: 满足 3NF, 消除表中的多值依赖

### 全文索引：

什么是全文索引（fulltext index）？

简单概括来说就是对 `非结构化数据`（不定长且无固定格式的数据）对其建立索引的过程。  
例如我们当我们需要从邮件、日志等大数据量的文本检索某个词的时候，一般只能顺序遍历扫描查找，但这样的效率很低，
所以就需要一种能够根据索引找到对应数据的方法。  
这就是倒排索引，先对数据进行分词分析，对关键词进行记录，找到对应的位置等信息，通过一个映射表（联想词典）映射索引位置关系。

MySQL中的倒排索引是基于红黑树实现的，同时Mysql的全文索引效率不高，因为存储结构为B+，导致在写入数据的时候非常消耗IO，
排序的过程中需要移动节点.

### 数据类型

char vs varchar

* varchar: 存储可变长的字符串，除了存储字符串str， 还额外使用 1/2 个字节存储字符串的长度，所以比定长字符串更节省空间，因为只使用了必要的空间。

    但在 UPDATE 的时候，由于行的变长，有可能导致页内没有空间可以存储，这种情况下，InnoDB 需要进行分裂页使得行可以放入页内
    
* char: 存储定长得字符串，采用填充空格得方式补充预定义得存储空间，非常适合存储一些定长得字符串例如（MD5值， BASE64编码字符串）

tips：所以在存储字符串到 char 得时候，如果有空格在字符串得左右边界得时候，会被忽略，而 varchar 则不会。当然最好还是一次性指定完字符串分配空间得大小，
      因为慷慨得给更长得字符串长度会占用更多得内存空间  
      还得注意一点：因为 SHA1(), MD5(), UUID()产生的字符串会分布在很大的空间内，局部缓存原理将导致 INSERT/SELECT 变得很慢，
      所以作为标识符的时候，尽量使用 int 代替 char
<br>


BLOB vs TEXT

都是为了存储大数据而设计得字符串数据类型，区别在于 BLOB 二进制存储，而 TEXT 以字符串方法存储  
与其他类型不同得是，当 BLOB 与 TEXT 的值太大的时候，InnoDB 会使用额外的空间存储字段值，并在原先的字段上使用1-4字节的指针指向对应的存储空间


DATETIME vs TIMESTAMP

DATETIME: 存储格式 ANSI 标准下的日期定义 "2019-11-15 16:59:50"
TIMESTAMP: 存储格式为 UNIX 时间戳，建议使用，因为更加节省存储空间



### 操作

alter table？

alter table 的方法是是用新的结构创建一个新的空表，然后从旧表中的数据插入到新表中，然后删除旧表。  
这个操作会导致服务不可用，所以通常做法是将在不提供服务的数据库中操作，然后提供服务的数据库进行切换


### 索引

#### 聚簇索引

聚簇索引 是一种数据存储方式，当表有聚簇索引的时候，数据行实际上存放在索引的叶子页上。因为无法同时将数据行放在两个不同的地方，  
所以一个表只能有一个聚簇索引。

优点：
* 可以把相关的数据保存在一起，例如如果以用户id为主键，那么索引过程中用户的数据可以通过读取少量的磁盘页实现，否则将导致多次的磁盘IO
* 数据访问更快，因为聚簇索引将数据行和索引放在同一棵 B- Tree，因此获取数据的时候会比非聚簇索引更快
* 使用覆盖索引扫描可以直接使用页节点中的主键值

缺点：
* 插入的速度严重依赖于插入的顺序，如果按照主键的顺序插入，将是最快的方式。如果不是的话，最好插入后 OPTIMIZE TABLE 重新组织表结构
* 更新聚簇索引的代价很高，因为插入新的数据会将每个被更新的数据行移动到新的位置
* 当插入数据的时候，有可能面临 “页分裂”，当行的主键值要求插入到某个已满的页中，存储引擎会将页分裂成两个页面来容纳该行，  
    页分裂会导致表占用更多的磁盘空间

#### 二级索引（非聚簇索引）

与聚簇索引相比，查找的时候需要访问两次 B- Tree，因为默认的 B-Tree 的叶子节点保存的不是指向行的物理位置指针，而是行的主键值  
者意味着，如果要查找行，存储引擎需要先找到二级索引的叶子节点获取对应的主键值，然后根据这个值去聚簇索引的 B-Tree找到对应的行  
（采用自适应哈希索引能减少这样的重复工作）

### 设计

如果维护一个自增的数据？

bad: table（cint），每次更新数据的时候都会 update set cint = cint + 1，这样存在的问题是，当并发量高得时候，因为会锁住对应得数据行，  
     所有得请求将会变成串行，导致并发量不高。
     
great: table 中维护 n 个 (cint, slot)，每次更新得时候 mod n，找到对应得 slot 数据行得cint 进行更新操作，  
        在计算总和得时候，sum(all)
        
        
   