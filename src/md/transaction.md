
## 事务

### 分布式事务解决方案

#### 两阶段提交/XA

两段提交：存在一个协调各个本地资源管理器（ResourceManager）的事务管理器(TransactionManager)，一般通过数据库实现。

流程：

1. 第一阶段(prepare)：事务管理器向所有本地资源管理器发起请求，询问是否是 ready 状态，所有参与者都将本事务是否成功的信息
发送给协调者（transactionManager），已经写入 redo log、binlog，但不 commit

2. 第二阶段（commit/rollback）：事务管理器根据本地资源管理器的反馈，通知所有 resourceManager 进行回滚或者是提交操作。


问题：

* 同步阻塞：当参与事务者存在占用公共资源的情况，其中一个占用，其他事务参与者就只能阻塞等待资源释放，处于阻塞状态

* 单点故障：一旦事务管理器出现故障，整个系统不可用

* 数据不一致：阶段二，如果因为网络问题，只有部分 resourceManager 接受到了 commit 消息，使得最终数据不一致

* 不确定性：当 transactionManager 发送 commit，且只有一个 resourceManager 接受到了 commit。一旦两边都宕机之后，
重新选举后的 new transactionManager 无法确定该消息是否已经提交成功。

####  TCC

* 解决了协调者单点，由业务方发起并完成这个活动，业务活动管理器变成多点，引入集群
* 同步阻塞：引入超时，超时后进行补偿，并不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小
* 数据一致性：有了补偿机制，由业务活动管理器控制一致性

TCC: try-confirm-cancel

1. try：尝试执行，完成所有业务检查（一致性），预留必须业务资源（准隔离性）
2. confirm：确认执行业务，不做任何检查（只使用 try 阶段预留的业务资源），confirm 操作需要保证幂等性（失败尝试）
3. cancel：执行取消，释放 try 阶段预留的业务资源，cancel 操作也需要满足幂等性

#### 本地消息表

1. A系统被其他系统调用发生数据库变更操作，首先会更新数据库的业务表，其次会向相同数据库的 __消息表__ 插入一条数据，
两个操作发生在一个本地事务中

2. 系统 A 的脚本定期轮询 __本地消息__ 往 mq 中写入一条消息，如果消息发送失败则进行重试

3. 系统 B 消费 mq 中的消息，并处理业务逻辑。如果本地事务处理失败，会继续消费 mq 中的消息进行重试。如果业务上的失败，
那么通知系统A 进行回滚。

[分布式事务](https://xiaomi-info.github.io/2020/01/02/distributed-transaction/)