

### TCP 三次握手

TCP 连接使用三次握手的原因：避免历史错误连接的建立，减少通信双方不必要的资源消耗

#### 如果建立连接时的通信只有两次？  

一旦发送方在发出建立连接的请求之后，就没办法撤回这个请求。当在网络状况复杂或者比较差的环境中，发送方没有收到应答，连续
发送请求连接请求，接收方只能接收或拒绝请求，导致发送方无法知道当前的连接状态（可能在建立后，接收方返回多个拒绝请求）。
所以在三次连接中引入了 RST 消息标志，接收方当收到请求时会将发送方发来的 `SEQ + 1` 发送回接收方，由接收方判断当前连接是否
为历史连接：

* 如果当前连接是历史连接，即 `SEQ` 过期或者超时，那么发送方就会直接发送 `RST` 控制消息中止这一次连接
* 如果当前连接不是历史连接，那么发送方就会发送 `ACK` 控制消息，通信双方就会成功建立连接

使用三次握手和 RST 控制消息是将是否建立连接的控制权交由发送方，因为只有发送方有足够的上下文判断当前连接是否是错误的或者是
过期的。

#### 同时维护着 初始序列号

* 数据包被发送方多次发送造成数据重复 （重复去除）
* 数据包在传输的过程中被路由或者其它节点丢失（重新发送）
* 数据包在接收方可能无法按照发送顺序（重排序）

### DNS (Domain Name System)

1. 先由本地的 DNS Client 向 DNS Resolver 解析器发出解析 `heiku.github.io` 的请求
2. DNS Resolver 首先向就近的根 DNS 服务器 `.` 请求顶级域名 DNS 服务的地址
3. 拿到顶级域名 DNS 服务 `io.` 的地址之后会向顶级域名服务请求负责 `github.io.` 域名解析的命名服务
4. 得到授权的 DNS 命名服务就可以根据请求的具体的主机记录直接向该服务请求域名对应的 IP 地址

（.）根域名、(io.)顶级域名、（github.io）二级域名、（heiku.github.com）子域名

#### 实现 （TCP & UDP）

DNS 查询的类型不止包含 A 记录（ip指向）、CNAME 记录（别名）等常见查询，还包括 AXFR 类型的特殊查询，这种特殊查询主要用于
 _DNS 区域传输_， 它的作用就是在多个命名服务器之间快速迁移记录，由于查询返回的响应比较大，所以会使用 TCP 协议进行传输
数据包。
 
在 _域名查找_ 的过程中，因为数据量小，且不需要稳定的连接，同时 TCP 在建立连接（三次握手），销毁连接（四次握手）会带来很大
的额外开销，这种情况在 DNS 解析器递归地与多个命名服务器进行通信时加倍开销。

但是，在区域查询中，因为一个 UDP 数据包的大小最多可以达到 64KB，虽然对于 DNS 查询已经时一个很大的数值（通常20），
但在实际生产中，一旦数据包中的数据超过传送链路中的最大单元（MTU，单个数据包大小的上限，一般为 1500 字节），当前数据包
就可能被分片传输、丢弃、部分的网络设备甚至会拒绝处理包请求，导致 UDP 协议在 _区域传输_ 中的不稳定，所以使用 TCP。


### 拥塞控制 & 流量控制

* _拥塞控制_ ：防止过多的数据包注入到网络中，防止了网络中的路由器或链路不至于过载。

* _流量控制_ ：往往指的是点对点通信的控制，抑制发送端发送的速率，以便接收端来得及接收。 

##### 为什么要进行拥塞控制

网络中的路由器会有一个数据包处理队列，当网络中存在太多的数据包时，处理队列一下子就被占满然后抛弃新来的数据包。而上层 TCP
 协议会认为数据包在网络中丢失，重新发送，但路由器又会继续丢弃，这样导致了网络性能的急剧下降，引起网络瘫痪。

#### 实现

慢开始、拥塞避免、快重传、快恢复

* _慢开始_ : 发送方按照发送窗口大小 cwnd 发送数据，接收方成功接收数据包后回复确认，这样发送方会继续调整 cwnd 的大小，
cwnd = 1, 2, 4 ..，慢开始的 "慢" 指的是并非一开始就将大量的数据包发给接收端，而是通过这种指数的方式预先增长发送窗口的大小。

* _拥塞避免_ : 由于指数增长会很快膨胀 cwnd 值，所以需要一个阈值 ssthresh 限制发送窗口大小，当 cwnd > ssthresh 时，开始使用
拥塞避免算法，从原来得 指数增长 -> 线性增长，cwnd + 1 

* _快重传_ : 原本当慢开始和拥塞避免在发送数据之后，会开启一个计时器，如果在指定时间内接收方没有发来确认时，执行乘法减小，
而 _快重传_ 让发送方在连续收到 3个重复的确认后就可以开始执行 _乘法减小_ 而不需要等待所设置的重传计时器到时。这就需要了
接收方在收到一个 _失序的报文段_ 时立即发送重复的确认。

* _快恢复_ : 当网络出现拥塞时并乘法减小（ssthresh * 1/2），并不是设置 cwnd = 1 并重新开始慢开始，而是让 cwnd = 乘法减小
后的新 ssthresh，并开始执行 _拥塞避免_ (cwnd + 1)


### ssl/tsl

SSL(Secure Sockets Layers) / TLS (Transport Layer Security)

1. 信息通过加密传输，第三方无法窃取
2. 具备校验机制，一旦被篡改，通信双方会立刻被发现
3. 配备身份证书，防止身份被冒充

#### 握手过程

![](/img/ssl-tsl.png)

##### Client Hello

1. 支持的协议，如 TLS 1.0
2. 支持的加密算法，如 RSA 公钥加密
3. 支持的压缩算法
4. _随机生成数_，用于生成 “对话密钥”

##### Server Hello

1. 确认使用的加密通信协议，如果支持版本不一致，则关闭
2. 确认使用的加密方法，如 RSA
3. 服务端证书
4. _随机生成数_，用于生成 “对话密钥”

响应之后，客户端将会持有 server random, 服务端将持有 client random  
（如果是安全系数较高的业务，通常会要求客户端提供安全证书）

##### Client Response

客户端在收到 Server Hello 之后，首先会验证 _服务器证书_ ，如果证书不是可信机构颁布、过期或者证书与域名不一致等，就会像
访问者显示一个警告，由访问者决定是否要继续通信。

如果没问题，将从证书中获取服务器的 _公钥_，
1. _生成随机数 (pre-master key)_，该随机数通过 _公钥_ 加密，防止被窃听
2. 编码通知改变，表示随后的信息都将通过双方商定的加密方法和密钥进行发送

##### Server Response

服务端收到客户端发来的第三个 random number（encrypted by public key from certificate）,这样双方都拥有了 三个随机数，然后
双方就会按照这三个随机数进行对称加密通信

1. 编码通知改变，表示随后的信息将用双方协定的加密方法和密钥发送
2. 服务器握手结束通知，表示服务器的握手阶段已经结束，这一项同时也是前面发送内容的 hash 值，用来供客户端校验


### "粘包" 问题

TCP 协议是面向字节流的传输层通信协议（没有消息边界），尽管发送方发送10,20,50这几个长度不同的数据包，但对于接收方而言，并不可知，而像是整体一样，
按自己的缓冲区大小有多少读多少。

#### Nagle 算法

Nagle 算法是一种通过减少数据包的方式提高 TCP 传输性能的算法。由于带宽有限，它不会将小的数据块直接发送到目标主机中，
而是会在本地缓冲区中等待更多的待发送的数据 （它会等待缓冲区中数据超过最大数据段（MSS）或者上一个数据段被 ACK 时，
才会发送缓冲区中的数据），这种批量发送数据的策略虽然会影响实时性和网络延迟，但能降低网络拥堵的可能性并减少额外开销。
（现在因为网络带宽不像以前那么紧张，所以 Linux 默认关闭 Nagle 算法：TCP_NODELAY = 1）

Nagle 算法虽然能够在数据包较小时提高网络带框的利用率，并减少 TCP 和 IP 协议头带来的额外开销，但是使用 Nagle 算法后可能
会导致应用层协议多次写入的数据被拆分发送，当接收方从 TCP 协议栈中读取数据时，会发现不相关的数据出现在同一个数据段中，
应用层协议可能没有办法对它们进行拆分和重组。

`TCP_CORK` 也是类似的延迟数据的发送，通过延迟发送数据来提高带宽的利用率，它们会对 __应用层__ 的数据进行拆分和重组， 
这类机制和配置能出现的原因是：TCP 是基于字节流的协议，其本身没有数据包的概念，
不会按照数据包发送数据。


#### 消息边界

既然 TCP 是基于字节流的，这意味着应用层协议要自己划分消息的边界，最常用的两种是基于长度和基于终结符（Delimiter）。

* 长度

基于长度的实现有两种方式，一种是使用固定的长度，所有的应用层都使用统一的大小，另一种



### 引用

[为什么 DNS 使用 UDP 协议 · Why's THE Design?](https://draveness.me/whys-the-design-dns-udp-tcp)  
[SSL/TLS协议运行机制的概述](https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)  
[如何理解传输层的TCP面向字节流，UDP面向报文？](https://www.zhihu.com/question/341865775)  
[TCP 流协议和消息分帧的理解](https://blog.csdn.net/lianliange85/article/details/50194975)