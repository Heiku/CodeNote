### Client

```
typedef struct redisClent{
    ... 
    robj *name;
    int fd;
    int flag;       // client role

    sds querybuf;       // input buffer, 服务端将解析 querybuf 转换成以下的 argv[], argc
    robj **argv;        // input["set", "key", "value"]
    int argc;           // len of argv

    struct redisCommand *cmd;       // 根据 argv[0] 找到对应的命令

    char buf[REDIS_REPLY_CHUNK_BYTES];      // output buffer
    int bufpos; 
}
```

根据客户端类型的不同，fd 属性的值可以为 -1 或者是 大于 -1 的整数：
* 伪客户端（fake client）：fd为 - 1，这种客户端b不需要使用到 socket 连接，通常会在两个地方使用到伪客户端，一个是载入 AOF 
文件并还原数据库状态，而另一个是执行 Lua脚本中的 Redis 命令。
* 普通客户端：普通客户端的 fd 属性值大于 - 1 的整数。

### Server

#### 命令过程

###### 查找命令实现
命令执行器会根据客户端状态的 argv[0] 参数，在命令表中 (command table) 查找参数指定的命令，并将找到的命令保存在客户端中的
 cmd 属性中。
命令表是一个字典，字典的键是命令的名字 "set", "get", "del" 等，而字典则是 redisCommand 结构，每个 redisCommand 结构记录了
一个 Redis 命令的实现。

##### 执行预备操作

服务器现在已经得到了执行命令所需的命令实现函数 (*cmd)，参数(argv[])，参数个数(argc),接着就是进行预备操作，判断操作是否
能正常执行：

* 检查 *cmd 是否为 NULL，是否无法找到对应的命令
* 检查 *cmd 中的 arity 属性，判断输入参数个数是否正确
* 检查客户端是否通过了身份验证（Auth）
* 如果服务器打开了 maxmemory，那么命令执行前先检查内存情况，需要时进行内存回收  
...

##### 命令执行

`client -> cmd -> proc(client)`

被调用的命令实现函数会执行指定的操作，并产生相应的命令回复，这些回复会保存在 client 中的输出缓冲区 (buf, reply)

##### 执行后续工作

* 如果服务器开启了慢日志功能，那么慢日志模块会检查是否需要为刚刚执行的命令请求添加慢日志记录。
* 如果服务器开启了 AOF 持久化，那么 AOF 持久化模块会将刚刚执行的命令追加写入到 AOF 文件中
* 如果有其他从服务器复制当前服务器，那么服务器会将刚刚执行的命令广播给从服务器

##### 回复发送给客户端

将客户端中的输出缓冲区发送给客户端，并清空缓冲区。


### 复制

Redis 的复制功能分为同步（sync）和 命令传播（command propagate）两个操作：
* 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态
* 命令传播操作则用于在主服务器的数据库状态被修改时，将命令传播至从服务器，使主从服务器的数据库重新回到一致状态

#### 同步

1. 从服务器向主服务器发送 SYNC 命令
2. 收到 SYNC 命令的主服务器执行 BGSAVE 命令，在后台生成一个 RDB 文件，并使用一个缓冲区记录从现在开始执行的所有写命令
3. 当主服务器的 BGSAVE 命令执行完毕后，主服务器会将 BGSAVE 命令生成的 RDB 文件发送给从服务器，从服务器接收并载入这个
RDB 文件，将自己的数据库状态更新至主服务器执行 BGSAVE 命令时的状态
4. 主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库
当前所处的状态


SYNC 命令（十分消耗资源的操作）：  
1. 主服务器需要执行 `BGSAVE` 命令生成 RDB 文件，这个生成操作会消耗主服务器大量的 CPU、内存和磁盘 I/O 资源
2. 主服务器需要将自己生成的 RDB 文件发送给从服务器，这个发送操作会消耗主从服务器大量的网络资源（带宽和流量），并对从服务器
相应命令请求的时间产生影响
3. 接收到 RDB 文件的从服务器需要载入主从服务器发来的 RDB 文件，并且在载入期间，从服务器会因为阻塞而没法处理命令请求。

#### 命令传播

在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的
写命令，主服务器与从客户端这时的出现数据不一致。就需要主服务器将自己执行的写命令发送给从服务器去执行，使双方状态一致。

存在的问题：  
当从服务器与主服务器断开连接后，从服务器如果在短时间内进行重连，连接后，还是需要向服务端发送 SYNC 命令进行数据同步，
这个过程没什么必要，因为时间短的话，只需要同步这段时间内的命令，而非全体数据。同时 SYNC 命令将会对主服务器造成性能影响。


#### 新复制

为了解决旧版复制功能在处理断线重复复制情况低效的问题，Redis 使用了 `PSYNC` 命令代替了 SYNC 进行同步操作。 `PSYNC` 命令具有
完成重同步（full resynchronization） 和 部分重同步（partial resynchronization）两种模式：
* 完成重同步和 `SYNC` 一样，借助于 RDB 进行数据的同步
* 部分重同步：用于处理断线后重复制情况，当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器
连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些命令，就可以将数据库更新至主服务器当前所处的状态。


### Sentinel

Sentinel（哨兵）使 Redis 的高可用性（high availability）解决方案：由一个或多个 Sentinel 实例（instance）组成的 Sentinel
系统可以监视多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下
的某个从服务器升级成新服务器，然后由新的主服务器代替已下线主服务器继续处理命令请求。

`redis-server sentinel.conf --sentinel`

1. 初始化服务器
2. 将普通 Redis 服务器使用的代码替换成 Sentinel 的专用代码（取消了set、get、eval、rdb、aof等功能）
3. 初始化 Sentinel 状态
4. 根据配置文件，初始化 Sentinel 的监视主服务器列表
5. 创建连向主服务器的网络连接


Sentinel 会向监视的主服务器建立两个网络连接：
1. 命令连接：用于向主服务器发送命令，接收命令回复
2. 订阅连接：用于订阅主服务器的 _sentinel_:hello 频道

#### 检测主观下线状态

默认情况下，Sentinel 会以每秒一次的频率向所有与它创建命令连接的实例（主从服务器、其他 Sentinel）发送 `PING` 命令，并通过
实例返回的 `PING` 命令回复（+PONG、-LOADING、-MASTERDOWN）判断实例是否在线。

Sentinel 配置了 `down-after-milliseconds` 选项指定了 Sentinel 判断实例进入主观下线所需要的时间长度，同时这个参数也可用于
主从及当前主服务器下的所有 Sentinel 主观下线状态。

#### 检查客观下线状态

当 Sentinel 将一个主服务器判断为主观下线之后，为了确认这个服务器是否真的下线，它会向同样监视这一主服务器的其他 Sentinel
进行询问，看它们是否也认为这个主服务器已进入下线状态。当 Sentinel 从其他 Sentinel 那里接收到足够数量的已下线判断之后，
Sentinel 就会从服务器判定为客观下线，并对主服务器执行故障转移操作。  