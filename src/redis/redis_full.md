### Client

```
typedef struct redisClent{
    ... 
    robj *name;
    int fd;
    int flag;       // client role

    sds querybuf;       // input buffer, 服务端将解析 querybuf 转换成以下的 argv[], argc
    robj **argv;        // input["set", "key", "value"]
    int argc;           // len of argv

    struct redisCommand *cmd;       // 根据 argv[0] 找到对应的命令

    char buf[REDIS_REPLY_CHUNK_BYTES];      // output buffer
    int bufpos; 
}
```

根据客户端类型的不同，fd 属性的值可以为 -1 或者是 大于 -1 的整数：
* 伪客户端（fake client）：fd为 - 1，这种客户端b不需要使用到 socket 连接，通常会在两个地方使用到伪客户端，一个是载入 AOF 
文件并还原数据库状态，而另一个是执行 Lua脚本中的 Redis 命令。
* 普通客户端：普通客户端的 fd 属性值大于 - 1 的整数。

### Server

#### 命令过程

###### 查找命令实现
命令执行器会根据客户端状态的 argv[0] 参数，在命令表中 (command table) 查找参数指定的命令，并将找到的命令保存在客户端中的
 cmd 属性中。
命令表是一个字典，字典的键是命令的名字 "set", "get", "del" 等，而字典则是 redisCommand 结构，每个 redisCommand 结构记录了
一个 Redis 命令的实现。

##### 执行预备操作

服务器现在已经得到了执行命令所需的命令实现函数 (*cmd)，参数(argv[])，参数个数(argc),接着就是进行预备操作，判断操作是否
能正常执行：

* 检查 *cmd 是否为 NULL，是否无法找到对应的命令
* 检查 *cmd 中的 arity 属性，判断输入参数个数是否正确
* 检查客户端是否通过了身份验证（Auth）
* 如果服务器打开了 maxmemory，那么命令执行前先检查内存情况，需要时进行内存回收  
...

##### 命令执行

`client -> cmd -> proc(client)`

被调用的命令实现函数会执行指定的操作，并产生相应的命令回复，这些回复会保存在 client 中的输出缓冲区 (buf, reply)

##### 执行后续工作

* 如果服务器开启了慢日志功能，那么慢日志模块会检查是否需要为刚刚执行的命令请求添加慢日志记录。
* 如果服务器开启了 AOF 持久化，那么 AOF 持久化模块会将刚刚执行的命令追加写入到 AOF 文件中
* 如果有其他从服务器复制当前服务器，那么服务器会将刚刚执行的命令广播给从服务器

##### 回复发送给客户端

将客户端中的输出缓冲区发送给客户端，并清空缓冲区。


### 复制

Redis 的复制功能分为同步（sync）和 命令传播（command propagate）两个操作：
* 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态
* 命令传播操作则用于在主服务器的数据库状态被修改时，将命令传播至从服务器，使主从服务器的数据库重新回到一致状态

#### 同步

1. 从服务器向主服务器发送 SYNC 命令
2. 收到 SYNC 命令的主服务器执行 BGSAVE 命令，在后台生成一个 RDB 文件，并使用一个缓冲区记录从现在开始执行的所有写命令
3. 当主服务器的 BGSAVE 命令执行完毕后，主服务器会将 BGSAVE 命令生成的 RDB 文件发送给从服务器，从服务器接收并载入这个
RDB 文件，将自己的数据库状态更新至主服务器执行 BGSAVE 命令时的状态
4. 主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库
当前所处的状态


SYNC 命令（十分消耗资源的操作）：  
1. 主服务器需要执行 `BGSAVE` 命令生成 RDB 文件，这个生成操作会消耗主服务器大量的 CPU、内存和磁盘 I/O 资源
2. 主服务器需要将自己生成的 RDB 文件发送给从服务器，这个发送操作会消耗主从服务器大量的网络资源（带宽和流量），并对从服务器
相应命令请求的时间产生影响
3. 接收到 RDB 文件的从服务器需要载入主从服务器发来的 RDB 文件，并且在载入期间，从服务器会因为阻塞而没法处理命令请求。

#### 命令传播

在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的
写命令，主服务器与从客户端这时的出现数据不一致。就需要主服务器将自己执行的写命令发送给从服务器去执行，使双方状态一致。

存在的问题：  
当从服务器与主服务器断开连接后，从服务器如果在短时间内进行重连，连接后，还是需要向服务端发送 SYNC 命令进行数据同步，
这个过程没什么必要，因为时间短的话，只需要同步这段时间内的命令，而非全体数据。同时 SYNC 命令将会对主服务器造成性能影响。


#### 新复制

为了解决旧版复制功能在处理断线重复复制情况低效的问题，Redis 使用了 `PSYNC` 命令代替了 SYNC 进行同步操作。 `PSYNC` 命令具有
完成重同步（full resynchronization） 和 部分重同步（partial resynchronization）两种模式：
* 完成重同步和 `SYNC` 一样，借助于 RDB 进行数据的同步
* 部分重同步：用于处理断线后重复制情况，当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器
连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些命令，就可以将数据库更新至主服务器当前所处的状态。


### Sentinel

Sentinel（哨兵）使 Redis 的高可用性（high availability）解决方案：由一个或多个 Sentinel 实例（instance）组成的 Sentinel
系统可以监视多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下
的某个从服务器升级成新服务器，然后由新的主服务器代替已下线主服务器继续处理命令请求。

`redis-server sentinel.conf --sentinel`

1. 初始化服务器
2. 将普通 Redis 服务器使用的代码替换成 Sentinel 的专用代码（取消了set、get、eval、rdb、aof等功能）
3. 初始化 Sentinel 状态
4. 根据配置文件，初始化 Sentinel 的监视主服务器列表
5. 创建连向主服务器的网络连接


Sentinel 会向监视的主服务器建立两个网络连接：
1. 命令连接：用于向主服务器发送命令，接收命令回复
2. 订阅连接：用于订阅主服务器的 _sentinel_:hello 频道

#### 检测主观下线状态

默认情况下，Sentinel 会以每秒一次的频率向所有与它创建命令连接的实例（主从服务器、其他 Sentinel）发送 `PING` 命令，并通过
实例返回的 `PING` 命令回复（+PONG、-LOADING、-MASTERDOWN）判断实例是否在线。

Sentinel 配置了 `down-after-milliseconds` 选项指定了 Sentinel 判断实例进入主观下线所需要的时间长度，同时这个参数也可用于
主从及当前主服务器下的所有 Sentinel 主观下线状态。

#### 检查客观下线状态

当 Sentinel 将一个主服务器判断为主观下线之后，为了确认这个服务器是否真的下线，它会向同样监视这一主服务器的其他 Sentinel
进行询问，看它们是否也认为这个主服务器已进入下线状态。当 Sentinel 从其他 Sentinel 那里接收到足够数量的已下线判断之后，
Sentinel 就会从服务器判定为客观下线，并对主服务器执行故障转移操作。  

#### 选举领头 Sentinel

当一个主服务器被判定为客观下线时，监视这个下线主服务器的各个 Sentinel 会进行协商，选举一个领头 Sentinel，并由领头 Sentinel
 对下线主服务器执行故障转移操作。每个 Sentinel 内部都会保存一个计数器-配置纪元 (configuration epoch)，用于记录下其它
 Sentinel 对自身发送的 `is-Master-down-by-addr` 支持命令，成为被支持者的局部领头，如果某个 Sentinel 被半数以上的 Sentinel
 设置成了局部领头 Sentinel，那么这个 Sentinel 将成为领头 Sentinel。

### 故障转移

在选举产生出领头 Sentinel 之后，领头 Sentinel 将对已下线的主服务器执行故障转移操作，包括以下：
1. 在已下线的主服务器属下的所有从服务器里，挑选一个从服务器，将其转换为主服务器
2. 让已下线主服务器属下的所有从服务器改为复制新的主服务器
3. 将已下线主服务器设置为新的主服务器的从服务器，这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。


#### 挑选新的主服务器（基于 Raft leader election）

领头 Sentinel 会将已下线主服务器下的所有从服务器保存在一个列表中，然后按照以下规则对列表进行筛选：

1. 删除列表中所有处于下线或者是断线状态的从服务器，保证列表中剩余的从服务器都是正常在线的。
2. 删除列表中所有最近5秒没有回复过领头Sentinel 的 INFO 命令的从服务器，保证列表中的剩余从服务器都是最近成功通信过的。
3. 删除所有已下线主服务器连接断开超过 `down-after-milliseconds * 10` ms的从服务器，保证剩余从服务器保存的数据都是较新的

之后，领头 Sentinel 根据从服务器的优先级，对列表中的剩余从服务器进行排序，并选出其中优先级最高的从服务器。  
如果有多个具有相同最高优先级的从服务器，那么领头 Sentinel 将按照从服务器的复制偏移量，选出偏移量较大的从服务器（复制
偏移量最大的从服务器就是保存着最新数据的从服务器）


剩余操作：
1. 领头 Sentinel 向挑选出的新主服务器发送 `SALVEOF no one`，升级为master 服务器
2. 通过 `SLAVEOF masterHost masterPort` 命令，修改从服务器的新复制目标
3. 还是通过 `SLAVEOF` 将旧的主服务器变为从服务器


### 集群

Redis 集群是 Redis 提供的分布式数据库方案，集群通过分片（sharding）进行数据共享，并提供复制和故障转移功能。

#### 节点

一个 Redis 集群由多个节点构成，通常，一个服务器就是一个节点（Node），可以通过 `CLUSTER MEET` 命令将多个 cluster 节点联系
起来。

Redis 集群中的节点分为主节点（master）和 从节点（slave），其中主节点用于处理槽，而从节点则用于负责某个主节点，并在复制
的主节点下线时，代替下线的主节点继续处理命令请求。

#### 槽指派

Redis 集群通过分片的方式保存数据库中的键值对，集群的整个数据库被分为 16384 个槽（slot），数据库中的每个键都属于这个 16384
 个槽的其中一个，集群中的每个节点可以处理 0 个或最多 16384 个槽。可以通过命令 `CLUSTER ADDSLOTS 0 ... 5000` 对当前节点
分配多个槽。

通过以下算法计算数据属于哪个槽（slot）：
```
def slot_number(key):
    return CRC16(key) & 16384
```

ASK 错误与 MOVED 错误的区别（临时重定向和永久重定向）:
* MOVED 错误代表槽的负责权已经从一个节点转移到另一个节点：在客户端收到关于槽 i 的 MOVED 错误之后，客户端每次遇到关于槽 i
 的命令请求之后，都可以直接将命令请求发送至 MOVED 错误指向的节点，因为该节点就是目前负责槽 i 的节点。
* 而 ASK 错误只是两个节点在迁移槽的过程中使用的一个临时措施：在客户端收到关于槽 i 的 ASK 错误之后，客户端在接下来的一次
命令请求中将关于槽 i 的命令请求发送至 ASK 错误所指向的节点，但这种转向不会对客户端今后发送关于槽 i 的命令请求产生影响，
客户端仍会将关于槽 i 的命令请求发送至目前负责处理槽 i 的节点，除非 ASK 错误再次发生。

#### 故障转移

当一个从节点发现正在负责的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，步骤如下：
1. 复制下线主节点的所有从节点里面，会有一个从节点被选中（参考领头 Sentinel）
2. 被选中的从节点执行 `SLAVEOF no one` ，成为主节点
3. 新的主节点会撤销所有对已下线主节点的槽指派（slot），并将这些槽全部指向自己
4. 新的主节点向集群广播一条 PONG 消息，这些 PONG 消息可以让集群中的其它节点立即知道这个节点已经由从节点变成了主节点，
并且这个主节点已经接管了原本由已下线节点负责处理的槽
5. 新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。