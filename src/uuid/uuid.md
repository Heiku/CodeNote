
### UUID

uuid(universally unique identifier) 用于表示唯一的业务id，通常用于用户ID, 订单ID， 信息ID

### 本地 UUID

randomOnly: 基于随机数生成 UUID, `UUID.randomUUID()` ，由于Java 中的随机数是伪随机数，所以产生的 id 是有可能重复的。
其次, 生成的 UUID 带有 `-`， 不利于作为数据库主键，不自增，不利于磁盘的顺序I/O

UUID 的优点：  
* 通过本地生成，没有经过网络 I/O，性能较快
* 无序，根本无法预测他的生成顺序（缺点之一）

缺点：  
* 128 位二进制一般转换成 36位的 16进制，因为太长所以只能通过 String 存储，空间占用很多
* 不能生成递增有序数字

### 数据库主键自增

优点：  
* 简单，有序自增，方便排序和分页

缺点：  
* 分表分库会带来问题，需要进行改造
* 并发性能不高，受限于数据库的性能
* 简单递增容易被猜测利用，比如有一个用户服务用的递增，那么其他人可以猜测出注册的ID得到当前有多少人注册，从而猜测出
服务的状况
* 数据库宕机服务不可用

### Redis 

Redis 主要是利用了 incr 和 incrBy 指令，通过Redis 的单线程保证原子性

优点：
* 性能比数据库好，能满足有序自增

缺点：
* 由于redis 是内存中的 KV 数据库，即使有 AOF 和 RDB，(内存溢出/并不是实时持久化)数据仍有可能消失，有可能造成 ID 重复
* 依赖于 redis，redis如果不稳定，会影响 ID 生成

### SnowFlake

雪花算法（SnowFlake）生成的 id 是一个64bit 的整数 （实现 [SnowFlake](/src/uuid/SnowFlake.java)）

* 1 bit: 符号位，不做处理
* 41 bit: 用于记录时间戳，可以持续记录69年
* 10 bit: 用来记录机器 ID, 总共可以记录 1024 台机器，一般用前5位代表数据中心，后面5位是某个数据中心的机器ID
* 12 bit：循环位，用来对同一个毫秒之内产生不同的ID, 12位可以最多记录 4095个，也就是在同一台机器下，同一毫秒最多记录
4095个，多余的需要进行等待下毫秒。那么一组机器一毫秒就可生成 1024 * 4095 个id。

优点：
* 生成的 id 依赖于内存，性能高
* 容量大，每秒可以生成大量的ID
* 所有生成的id 按时间趋势递增，后续插入数据库的索引树的时候，性能较高
* 整个分布式系统内不会产生重复的id （dataCenterId & workerId 保证）

缺点：
* 依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成 ID 冲突，或者 ID 乱序

workId 怎么保证唯一性？  
可以通过分布式缓存来保存机器 ID 和 workId 之间的映射关系，启动的时候访问分布式缓存查询当前机器 ID 对应的 workId，
如果查询不到获取一个并保存在分布式缓存中。

#### 时钟回拨？

因为机器的原因会发生时间回拨，雪花算法是强依赖于系统的时间，如果发生时间回拨，有可能会生成重复的ID。

* 如果时间回拨时间比较短，比如配置5ms 以内，那么可以一直等待一定的时间，让机器的时间追上来
* 如果时间回拨的时间比较长，我们不能接受这么长时间的阻塞，这时有两个策略：

1. 直接拒绝，抛出异常，打日志，通知RD 时间回滚
2. 利用扩展位，当时间回拨比较长的时候，我们不需要等待，直接在扩展位加1。 这样2位的扩展位允许我们有三次大的时间回拨，
如果还是超出，那么抛出异常，打日志。


   
