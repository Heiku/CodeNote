
### UUID

uuid(universally unique identifier) 用于表示唯一的业务id，通常用于用户ID, 订单ID， 信息ID

### 本地 UUID

randomOnly: 基于随机数生成 UUID, `UUID.randomUUID()` ，由于Java 中的随机数是伪随机数，所以产生的 id 是有可能重复的。
其次, 生成的 UUID 带有 `-`， 不利于作为数据库主键，不自增，不利于磁盘的顺序I/O

UUID 的优点：  
* 通过本地生成，没有经过网络 I/O，性能较快
* 无序，根本无法预测他的生成顺序（缺点之一）

缺点：  
* 128 位二进制一般转换成 36位的 16进制，因为太长所以只能通过 String 存储，空间占用很多
* 不能生成递增有序数字

### 数据库主键自增

优点：  
* 简单，有序自增，方便排序和分页

缺点：  
* 分表分库会带来问题，需要进行改造
* 并发性能不高，受限于数据库的性能
* 简单递增容易被猜测利用，比如有一个用户服务用的递增，那么其他人可以猜测出注册的ID得到当前有多少人注册，从而猜测出
服务的状况
* 数据库宕机服务不可用

### Redis 

Redis 主要是利用了 incr 和 incrBy 指令，通过Redis 的单线程保证原子性

优点：
* 性能比数据库好，能满足有序自增

缺点：
* 由于redis 是内存中的 KV 数据库，即使有 AOF 和 RDB，(内存溢出/并不是实时持久化)数据仍有可能消失，有可能造成 ID 重复
* 依赖于 redis，redis如果不稳定，会影响 ID 生成

### SnowFlake

雪花算法（SnowFlake）生成的 id 是一个64bit 的整数

* 1 bit: 符号位，不做处理
* 41 bit: 用于记录时间戳，可以持续记录69年
* 


   
