
### CPU Cache

CPU 缓存：CPU 与内存之间的临时存储器，按照数读取顺序和 CPU 结合的紧密度，CPU 缓存可以分为 (CPU) L1、L2、L3 (内存)。
越接近 CPU 的缓存越快也越小。

当不同的核需要访问其它核缓存的数据时，就需要 MESI 协议保证缓存的相干性和内存的相干性，其中 M、E、S、I 代表了使用 MESI 
协议缓存行所处的状态：
* M (Modified，修改): 本地处理器已经修改了缓存行，即出现脏行，缓存行中的数据与内存中的数据不一样，并且此 Cache 只有本地
一个拷贝
* E (Exclusive，专有): 缓存行中的数据与内存中一致，且其它处理器没有这行数据
* S (Shared，共享): 缓存行中的数据与内存中一致，与其它核的缓存行共享数据拷贝
* I (Invalid，无效): 缓存行失效，不能使用

![](/img/MESI.jpg)

在 MESI 协议中，每个 cache 的 Cache 控制器不仅知道自己的读写操作，而且也监听其它 Cache 的读写操作。每个 cache line 所处
的状态根据本核和其它核的读写操作在这 4 个状态中进行转移


#### 数据访问

当不同的 cpu core 修改缓存了相同数据的缓存行时，core1 修改成功之后，core2 对应的缓存行需要设置成 I(invalid) 状态。  

CPU 访问主内存，都是通过 cache 间接访问主存，每次需要访问主存时，遍历一遍全部 cache line，查找主存的地址是否在某个
 cache line 中，如果在，先判断数据是否有效（根据 MESI 协议状态），有效则直接使用。如果不在则数据无效，把主存中的内存数据
 copy 到 cache line 上，再从 cache line 中读取。

### 缓存更新

缓存的更新通常是采用 `缓存删除` 的方式，如果是更新缓存，在并发情况下，不能保证更新数据库的顺序和更新缓存的顺序一致，
那就会出现数据库和缓存中数据不一致的情况。

#### 为什么更新缓存通常是删除缓存而不是更新缓存？

这是一种懒加载的思想，如果这个数据在某段时间内需要进行大量更改，但访问量缺很少，这样在每次更改 mysql 数据的时候
（特别是涉及到多行更新，并计算缓存值的时候），都需要重新计算缓存值大小，然后更新缓存这样的造成了cpu资源的浪费，而直接删除后，
当下次需要该数据时再进行计算，然后设置为最新的缓存。

缓存的更新一般有两种情况：
* 先删除缓存，在更新数据库

先删除缓存，再更新数据库，存在的问题是：当缓存删除完后，还没更新数据库之前，有请求将直接进入到 db 中，这时读到的数据将
会是旧数据，然后这个请求将会将旧数据缓存，然后后续的操作都将直接访问缓存中的旧数据。

* 先更新数据库，再删除缓存（推荐）

先更新数据库，再删除缓存，这样就避免了上面出现的问题，同时引入了新的问题：如果当前数据是没有缓存的，查询的请求将直接落库，
再更新操作之前，有一个查询请求将读取就数据库的值并再更新操作回填缓存之后将数据覆盖，这样导致的缓存和数据库出现缓存不一致
的情况。（但出现的概率低，很少会有查询操作的回填操作比更新操作的删除后触发）


### 缓存场景

#### 缓存穿透

缓存穿透是指查询的数据在数据库是没有的，那么缓存中自然也没有。所有的请求将直接落在数据库上，数据库压力很大。

避免方法：  
1. 对于返回 NULL 的依旧缓存，但抛出异常的不缓存，注意设置较短的超时时间避免长时间的空值返回。
2. 指定一些规则过滤一些不可能存在的数据，小数据用 Bitmap，大数据用 bloom filter
 
#### 缓存击穿

缓存击穿指的是对于某些key 设置了过期时间,但是其是热点数据,如果某个 key 失效,可能大量的请求打过来,然后请求将
直接访问数据库,这时数据库访问量急剧增加.

避免方法:  
* 如果数据基本不变：设置缓存永不过期
* 如果数据更新不频繁：采用分布式锁，保证仅有少量的请求能够请求数据库并重新构建缓存，其余线程只能在锁释放后访问缓存
* 如果视剧更新频繁：利用定时线程在缓存过期前主动重新构建缓存或者延后缓存的过期时间，保证所有的线程能够一直访问到对应的缓存

1. 分布式锁:加载数据的时候可以利用分布式锁锁住这个数据的key, 在 Redis 中直接使用 setnx 操作即可,对于获取到这个锁的线程,
查询数据库更新缓存,其他线程采用重试策略,这样数据库不会同时受到很多线程访问同一条数据
2. 异步加载: 由于缓存击穿是热点数据才会出现的问题,可以对这部分热点数据采取自动刷新的策略,而不是到期自动淘汰.
淘汰其实也是为了数据的时效性,所以采取自动刷新也可以.

#### 缓存雪崩

缓存雪崩是指缓存不可用或者大量缓存由于超时时间相同在同一时间失效,大量的请求直接访问数据库,导致数据库压力过大从而系统崩溃.

避免方法:  
1. 增加缓存系统的可用性,通过监控关注缓存的健康程度,根据业务量适当的扩容缓存
2. 采用多级缓存,不同级别缓存设置的超时时间不同,即使某个级别的缓存都过期,也有其他级别的缓存兜底
3. 缓存的过期时间可以取个随机值,比如以前是设置10 min 的超时时间,那每个 key 都可以随机 8-13min过期,尽量让不同的key的过期时间
不同. 

### 引用

[伪共享之CPU缓存](http://b.shiwuliang.com/%E4%BC%AA%E5%85%B1%E4%BA%AB%E4%B9%8BCPU%E7%BC%93%E5%AD%98.html)